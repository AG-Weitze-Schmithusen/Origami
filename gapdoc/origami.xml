<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE Book SYSTEM "gapdoc.dtd">
<Book Name="Origami Package">

<TitlePage>
  <Title>The <Package>Origami</Package> Package</Title>
  <Subtitle>Computing Veechgroups of Origamis</Subtitle>
  <Date>13.11.2018</Date>
  <Version>Version 1.0.0</Version>
  <Author>Pascal Kattler
    <Email>kattler@math.uni-sb.de</Email>
    <Homepage>http://www.math.uni-sb.de/ag/weitze/</Homepage>
    <Address>
      AG Weitze-Schmithüsen<Br/>
      FR 6.1 Mathematik<Br/>
      Universität des Saarlandes<Br/>
      D-66041 Saarbrücken<Br/>
    </Address>

  </Author>
  <Author>Andrea Thevis
    <Email>thevis@math.uni-sb.de</Email>
    <Homepage>http://www.math.uni-sb.de/ag/weitze/</Homepage>
    <Address>
      AG Weitze-Schmithüsen<Br/>
      FR 6.1 Mathematik<Br/>
      Universität des Saarlandes<Br/>
      D-66041 Saarbrücken<Br/>
    </Address>
  </Author>

    <Copyright>&copyright; 2018 by Pascal Kattler
    </Copyright>

    <Acknowledgements>
We thank Sergio Siccha for his support and valuable input at the
beginning of this project. Further, we would like to thank Vincent
Delecroix and Samuel Lelièvre for fruitful discussions about algorithms
implemented in the surface_dynamics package in sage. Some of the
functionality of the surface_dynamics package can be used in this
package as well. For this we use an interface between &GAP; and sage. We
are thankful to Mohamed Barakat and Markus Pfeiffer for helping using
the interfaces. Moreover, we thank Thomas Breuer for helpful ideas and comments on some
algorithms implemented in this package.

<Par/>

This software package is part of the project I.8 'Algorithmic approaches to Teichmüller curves'
(AG Weitze, Saarland University) supported by Project I.8 of SFB-TRR 195 'Symbolic Tools in
Mathematics and their Application' of the German Research Foundation (DFG).
    </Acknowledgements>


  </TitlePage>

<TableOfContents/>

<Body>
<Chapter> <Heading> Introduction </Heading>
  <Section> <Heading>Overview</Heading>
    <!--<Section Label="sec:theory"> <Heading>Introduction</Heading> -->
    This package provides calculations with a certain class of translation surfaces called origamis. An origami (also known as square-tiled surface)
    is a finite covering of a torus which is ramified at most over one point. It can be described in the following way from
    two permutations <M>\sigma_x, \sigma_y \in S_d</M>. We take <M>d</M> squares <M>Q_1, \dots, Q_d</M> and glue the lower side of
    <M>Q_i</M> to the upper side of <M>Q_{\sigma_y(i)}</M> and the right side of <M>Q_i</M> to the left side of <M>Q_{\sigma_x(i)}</M>.
    We require origamis to be connected and thus the group generated by <M>\sigma_x</M> and <M>\sigma_y</M>  acts transitively on <M>\{1,\dots,d\}</M>.
    In this package we identify an origami with a pair of permutations, which acts transitively on <M>\{1, \dots, d\}</M> up
    to simultaneous conjugation. This corresponds to renumbering the labels of the squares. By choosing a certain numbering in a canonical way one can
    achieve a canonical representative.

<Par/>

    In this package we are mainly interested in Veech groups of origamis. They are subgroups of finite index of
    <M>SL_2(\mathbb{Z})</M> which carry a lot of information about the geometric and dynamic properties of the underlying translation surface.
    For further information about origamis and translation surfaces in general see e.g.<Cite Key = "PHD1" />, <Cite Key = "PHD2" />, <Cite Key = "MR2214127" />, <Cite Key = "Lec" /> and <Cite Key = "MR2261104" />.
</Section>
<Section> <Heading> Notations </Heading>
    Since we are mainly interested in the Veech group of an origami, which are a subgroups of <M>SL_2(\mathbb{Z})</M> of finite index,
 we fix two generators of <M>SL_2(\mathbb{Z})</M>
    <Display>
      S =
     \left( {\begin{array}{cc}
      0 &amp; -1 \\
      1 &amp; 0 \\
     \end{array} } \right)
   </Display>

    and

    <Display>
      T =
     \left( {\begin{array}{cc}
      1 &amp; 1 \\
      0 &amp; 1 \\
     \end{array} } \right).
   </Display>




    In this package we fix the free group <M>F</M> generated by <M>\tilde{S}</M> and <M>\tilde{T}</M>.
    We consider the canonical epimorphism <M>\pi: F\to SL_2(\mathbb{Z})</M> with <M>\pi(\tilde{S})=S</M> and <M>\pi(\tilde{T})=T</M>.




</Section>
</Chapter>
<Chapter> <Heading> The functionality of this package </Heading>
    <Section> <Heading>The Origami Object</Heading>

    In this section we introduce a new type called 'origami', namely origami objects, which are created
    by this two permutations. The degree of an origami is the number of squares. Origamis are stored as such objects.


<Br/>

<ManSection>


  <Func Name="Origami" Arg="permX , permY"/>
 <Returns>An Origami.</Returns>
        <Description>
		This function generates a new origami object with <M> \sigma_x =</M> <Arg> permX </Arg>, <M> \sigma_y =</M> <Arg> permY </Arg>.
                The function tests whether (<Arg> permX </Arg>,<Arg> permY </Arg>) defines a connected surface and returns false otherwise.
        <Example>
gap> Origami((1,2), (2,3));
Origami((1,2), (2,3), 3)
        </Example>
        </Description>

 <Func Name="OrigamiNC" Arg="permX , permY, d"/>
 <Returns>An Origami.</Returns>
  <Description>
This function does the same as <Ref Func="Origami"/>, but in contrast it does not test,
    whether the origami describes a connected surface. <Br/>
  </Description>



<Func Name="OrigamiNormalForm" Arg="origami"/>
 <Returns>An Origami.</Returns>
<Description>
          This function calculates a canonical representation of <Arg> origami</Arg>. Two origamis are equivalent, if they have the same canonical representation. This function has been implemented by Luca Junk and the algorithm is from <Cite Key = "ONF" />.
<Example>
gap> OrigamiNormalForm(Origami((1,3,5,7)(2,8,4,10)(6,9),
>(1,5,2,6,3)(4,10)(7,9) ));
Origami((1,2)(3,5,4,6)(7,8,9,10), (1,3)(2,4,5,6,7)(9,10), 10)
</Example>
</Description>

        <Fam Name="OrigamiFamily"/>
        <Description>
          Since origamis do not fit in any existing family in &GAP;, we introduce a new family for origami objects called OrigamiFamily. <Br/>
        </Description>


        <Attr Name="HorizontalPerm" Arg="origami"/>
 		<Returns>A permutation.</Returns>
        <Description>
           This function returns the horizontal permutation <M>\sigma_y</M> of an origami.
<Example>
gap> HorizontalPerm(Origami((1,3,5), (1,3)(2,4,5)));
(1,3,5)
</Example>
        </Description>

        <Attr Name="VerticalPerm" Arg="origami"/>
		<Returns>A permutation.</Returns>
        <Description>
            This function returns the vertical permutation <M>\sigma_x</M> of an origami.
<Example>
gap> VerticalPerm( Origami((1,3,5), (1,3)(2,4,5) ));
(1,3)(2,4,5)
</Example>
        </Description>

        <Attr Name="DegreeOrigami" Arg="origami"/>
 		<Returns>An Int.</Returns>
        <Description>
        This function returns the degree of an origami.
<Example>
gap> DegreeOrigami(Origami((1,3,5), (1,3)(2,4,5) ));
5
</Example>
        </Description>

        <Attr Name="Stratum" Arg="origami"/>
		 <Returns>A list of Ints.</Returns>
        <Description>
           This function calculates the stratum of an origami. The stratum of an origami is a list of the nonzero degrees
           of the singularities. For a singularity of cone angle <M>2\pi k</M> the degree of the singularity is <M>k-1</M>.
<Example>
gap> Stratum(Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6) ));
[ 1, 5 ]
</Example>
        </Description>

        <Attr Name="Genus" Arg="origami"/>
		 <Returns>An Int.</Returns>
        <Description>
         This function calculates the genus of the origami surface.
<Example>
gap> Genus( Origami((1,2,3,4),(1,2)(3,4) ) );
2
</Example>
        </Description>
</ManSection>

</Section>
<Section> <Heading>SL_2(Z)-Action on Origamis</Heading>


        The group <M>SL_2(\mathbb{Z}) </M> acts on the set of origamis of fixed degree. The following methods help calculating this
        operation both for matrices and words in the free group <M>F</M>.

<Br/>


<ManSection>
<Meth Name="ActionOfSpecialLinearGroup" Arg="word, origami"/>
		 <Returns>An Origami object.</Returns>
        <Description>
          Given a word <Arg>word</Arg> in the free group  <M>F=</M> <M>Group(\tilde{S}, \tilde{T})</M> this function computes
          <M>\pi(<Arg>word</Arg>) \in SL_2(\mathbb{Z})</M> and returns <M>\pi(<Arg>word</Arg>).<Arg>origami</Arg></M>. The word is given
          as a string, as shown in the following example.
<Example>
gap> ActionOfSpecialLinearGroup("ST",Origami((1,3,5), (1,3)(2,4,5)));
Origami((1,3)(2,5,4), (2,4,5,3), 5)
</Example>
        </Description>
		 <Returns>An Origami.</Returns>
        <Meth Name="ActionOfSpecialLinearGroup" Arg="matrix, origami"/>
        <Description>
          Given matrix in <M>SL_2(\mathbb{Z}) </M> this function returns <Arg>matrix</Arg>.<Arg>origami</Arg>.
<Example>
gap> ActionOfSpecialLinearGroup([ [ 0, -1 ], [ 1, 1 ] ], Origami((1,3,5),
>(1,3)(2,4,5)));
Origami((1,3)(2,5,4), (2,4,5,3), 5)
</Example>
        </Description>

<Func Name="ActionOfF2ViaCanonical" Arg="origami, word"/>
<Returns>An Origami.</Returns>
<Description>
 Given a word <Arg>word</Arg> in the free group  <M>Group(\tilde{S}, \tilde{T})</M> this function computes
 <M>\pi(<Arg>word</Arg>) \in SL_2(\mathbb{Z})</M> and returns <M>\pi(<Arg>word</Arg>).<Arg>origami</Arg></M>.
 But in contrast to <Ref Func="ActionOfSpecialLinearGroup"/> the result is stored in the canonical representation.
 ATTENTION: the order of arguments is switched compared to the order of the arguments in the function <Ref Func="ActionOfSpecialLinearGroup"/>.
  <Example>
gap> ActionOfF2ViaCanonical(Origami((1,2), (1,3)), "S");
Origami((1,2), (2,3), 3)
  </Example>
</Description>

<Func Name="RightActionOfF2ViaCanonical" Arg="origami, word"/>
 <Returns>An Origami.</Returns>
<Description>
  This function computes the right action of the projection of a word <Arg>word</Arg> in the free group <M>Group(\tilde{S}, \tilde{T})</M> on an origami <Arg>origami</Arg>.
 It returns <M><Arg>origami</Arg>.\pi(<Arg>word</Arg>) = \pi(<Arg>word</Arg>)^-1.<Arg>origami</Arg></M>, where the left action
 is the common action of <M>SL_2(\mathbb{Z})</M> on origamis of a given degree. This action has
 the same orbits as the left action. For the Veech group computation both actions
 can be used and give the same result. In contrast to
 <Ref Func="ActionOfSpecialLinearGroup" /> the result is stored in the canonical representation.
 ATTENTION: the order of arguments is switched compared to the order of the arguments in the function <Ref Func="ActionOfSpecialLinearGroup" />.
 <Example>
gap> RightActionOfF2ViaCanonical(Origami((2,3), (1,3,2)),"T");
Origami((1,2), (2,3), 3)
</Example>
</Description>
</ManSection>





</Section>
<Section> <Heading>Veech groups</Heading>

           The Veech group <M>G</M> of an origami is a subgroup <M>SL_2(\mathbb{Z})</M> of finite index. The group is
           stored as a ModularSubgroup from the <Package>ModularSubgroup</Package>
           package. It is represented by two permutations <M>\sigma_S</M> and <M>\sigma_T</M> describing how the generators
           <M>S</M> and <M>T</M> of <M>SL_2(\mathbb{Z})</M> act on the cosets of <M>G</M> in <M>SL_2(\mathbb{Z})</M>.
           E.g, if <M>SH_i = H_j</M> and <M>H_i,H_j</M> are the cosets associated to integers <M>i,j</M>, respectively, then
           <M>\sigma_S(i)=j</M>.

           See <Cite Key="MR2118271"/> for a detailed version of the algorithm.

<Par/>

<ManSection>
        <Attr Name="VeechGroup" Arg="origami"/>
		 <Returns>A ModularSubGroup.</Returns>
        <Description>
           This function calculates the Veech group of an origami.

           You get the coset permutations using the <Package>ModularSubgroup</Package> package as in the following example.
        <Example>
gap> SAction(VeechGroup(Origami((1,2,5)(3,4,6), (1,2)(5,6) )));
(1,3)(2,5)(4,7)(6,8)(9,10)
gap> TAction(VeechGroup(Origami((1,2,5)(3,4,6), (1,2)(5,6) )));
(1,2,4)(3,6)(5,8,7,9,10)
        </Example>
        </Description>

        <Attr Name="Cosets" Arg="origami"/>
		 <Returns>A list of element of the free group with generators S and T.</Returns>
        <Description>
           This function calculates the right cosets of the Veech group of an origami as a list of words in <M>S</M>
           and <M>T</M>.
<Example>
gap> Cosets(Origami((1,2,5)(3,4,6), (1,2)(5,6), 6));
[ &lt;identity ...>, S, T, T^-1, S*T, S*T^-1, T*S, T^-1*S, S*T*S, S*T^-1*S ]
</Example>
        </Description>
		 <Returns>A boolean.</Returns>
        <Func Name="EquivalentOrigami" Arg="origami1, origami2"/>
        <Description>
          This function tests whether <Arg>origami1</Arg> is equal  to <Arg>origami2</Arg> up to renumbering of the squares.
<Example>
gap> EquivalentOrigami(Origami((1,4)(2,6,3), (1,5)(2,3,6,4) ), Origami((1,4,3)
>(2,5), (1,5,3,4)(2,6) ));
true

gap> EquivalentOrigami(Origami((1,4)(2,6,3), (1,5)(2,3,6,4) ), Origami((1,2,5)
>(3,4,6), (1,2)(5,6) ));
false
</Example>
</Description>
</ManSection>
At this point we thank Thomas Breuer for the idea to implement the  latter function.


</Section>
<Section> <Heading>Lists of Origamis</Heading>
The following functions generate lists of origamis of a given degree (and stratum).

<Br/>

<ManSection>
<Func Name="OrigamiList" Arg="d"/>
 <Returns>A list of Origamis.</Returns>
<Description>
	This function calculates a list of all origamis with a given degree <Arg>d</Arg>.
<Example>
gap> OrigamiList(2);
[ Origami((), (1,2), 2), Origami((1,2), (), 2), Origami((1,2), (1,2), 2) ]
</Example>
</Description>


<Func Name="OrigamiListWithStratum" Arg="d, stratum"/>
 <Returns>A list of Origamis.</Returns>
<Description>
	This function calculates a list of all origamis with a given degree <Arg>d</Arg> and stratum <Arg>stratum</Arg>.
<Example>
gap> OrigamiListWithStratum(5, [1,1]);
[ Origami((1,2), (1,3)(2,4,5), 5), Origami((1,2), (1,3,2,4,5), 5),
  Origami((1,2,3), (1,2)(3,4,5), 5), Origami((1,2,3), (2,3,4,5), 5),
  Origami((1,2,3), (2,4,5,3), 5), Origami((1,2)(3,4,5), (2,3), 5),
  Origami((1,2)(3,4,5), (1,2,3), 5), Origami((1,2)(3,4,5), (2,3,4,5), 5),
  Origami((1,2)(3,4,5), (2,3,5,4), 5), Origami((1,2)(3,4,5), (1,2,3,4,5), 5),
  Origami((1,2)(3,4,5), (1,2,3,5,4), 5), Origami((1,2,3,4), (3,4,5), 5),
  Origami((1,2,3,4), (3,5,4), 5), Origami((1,2,3,4), (1,2,3)(4,5), 5),
  Origami((1,2,3,4), (1,3,2)(4,5), 5), Origami((1,2,3,4), (2,3,4,5), 5),
  Origami((1,2,3,4), (2,5,4,3), 5), Origami((1,2,3,4), (1,2,4,5,3), 5),
  Origami((1,2,3,4), (1,3,5,4,2), 5), Origami((1,2,3,4,5), (3,5), 5),
  Origami((1,2,3,4,5), (1,2)(3,4,5), 5), Origami((1,2,3,4,5), (1,2)(3,5,4), 5)
    , Origami((1,2,3,4,5), (2,4,3,5), 5), Origami((1,2,3,4,5), (2,5,3,4), 5) ]
</Example>
</Description>
</ManSection>

</Section>
</Chapter>
<Chapter> <Heading> SageMath functions </Heading>
<Section> <Heading> Using SageMath functions</Heading>
The SageMath Package surface_dynamics from Vincent Delecroix <Cite Key="Delecroix"/> provides functions to study origamis.
To use the functions of this chapter, Sage and the surface_dynamics package must be installed on your operation system. Furthermore, the &GAP; packages
<Package>homalgto</Package>, <Package>io_forhomalg</Package>, <Package>io</Package> and <Package>rings</Package> must be installed.


<Br/>



The following descriptions and examples
are mainly taken from the manual of <Cite Key="Delecroix"/>.

<Br/>

<ManSection> <Heading> SageMath </Heading>
<Func Name="VeechgroupBySage" Arg="origami"/>
 <Returns>A ModularSubGroup.</Returns>
<Description>
	This function executes the SageMath method veech_group to <Arg>origami</Arg> and returns its result as &GAP; object. It does the same as <Ref Func="VeechGroup"/>.
<Example>
gap> VeechgroupBySage(Origami((1,3,5), (1,3)(2,4,5) ));
&lt;modular subgroup of index 24>

</Example>
</Description>

<Func Name="NormalFormBySage" Arg="origami"/>
 <Returns>An Origami.</Returns>
<Description>
	This function executes the SageMath method to_standard_form to <Arg>origami</Arg> and returns its result as &GAP; object.
In principle, it calculates a canonical representative by changing the numbering of the squares like the function <Ref Func="OrigamiNormalForm"/>.
But it chooses another representation.
<Example>
gap> NormalFormBySage(Origami((1,3,5), (1,3)(2,4,5) ));
Origami((3,4,5), (1,2,3)(4,5), 5)
</Example>
</Description>
<Func Name="IsHyperellipticBySage" Arg="origami"/>
 <Returns>A boolean.</Returns>
<Description>
	This function executes the SageMath method IsHyperelliptic to <Arg>origami</Arg> and returns its result as &GAP; object. It tests, weather <Arg>origami</Arg> is hyperelliptic.
<Example>
gap> IsHyperellipticBySage(Origami((1,3), (1,2) ));
true
</Example>
</Description>

<Func Name="IsPrimitiveBySage" Arg="origami"/>
 <Returns>A boolean.</Returns>
<Description>
	This function executes the SageMath method IsPrimitive to <Arg>origami</Arg> and returns its result as &GAP; object. An origami is primitive if it does not cover an other origami.
	An origami is primitive if the action of the monodromy group has no
   non trivial block.
<Example>
gap> IsPrimitiveBySage(Origami((1,3), (1,2) ));
true
gap> IsPrimitiveBySage(Origami((1,2)(3,4), (1,3,5,6)(2,4) ));
false
</Example>
</Description>

<Func Name="ReduceBySage" Arg="origami"/>
 <Returns>An Origami.</Returns>
<Description>
	This function executes the SageMath method Reduce to <Arg>origami</Arg> and returns its result as &GAP; object. It returns a reduced origami isomorphic (up to <M>SL(2,\mathbb{Q})</M> action) to that origami.
<Example>
gap> ReduceBySage(Origami((1,2)(3,4), (1,3,5,6)(2,4) ));
Origami((1,2), (1,3), 6)
</Example>
</Description>

<Func Name="AbsolutePeriodGeneratorsBySage" Arg="origami"/>
 <Returns>A list of lists of Ints.</Returns>
<Description>
	This function executes the SageMath method AbsolutePeriodGenerators to <Arg>origami</Arg> and returns its result as &GAP; object. It return a generating set of the absolute periods of this origami.
	To each curve on an origami, we can associate its holonomy (that is
   an element of <M> \mathbb{Z} \times \mathbb{Z}</M>). This function returns a generating
   set of the module generated by holonomies of closed curves.
<Example>
gap> AbsolutePeriodGeneratorsBySage(Origami((1,2,3,4)(5,6), (1,5)(2,6) ));
[ [ 2, 0 ], [ 2, 0 ], [ 0, 1 ], [ 0, 1 ] ]
</Example>
</Description>

<Func Name="LatticeOfAbsolutePeriodsBySage" Arg="origami"/>
<Returns>A list of lists of Ints.</Returns>
<Description>
	This function executes the SageMath method LatticeOfAbsolutePeriods to <Arg>origami</Arg> and returns its result as &GAP; object. It returns (a,t,u) where ((a,0),(t,u)) is a standard basis for the
   lattice of the absolute periods of self.
	The lattice of periods of an origami is the sublattice of <M> \mathbb{Z}^2</M>
   generated by the holonomy vectors of its saddle connections. Any
   sublattice of <M> \mathbb{Z}^2</M> has a standard basis consisting of a horizontal
   vector (a,0) and a nonhorizontal vector (t,u), where a, t, u are
   integers satisfying 0 &lt; t &lt; a and 0 &lt; t.
<Example>
gap> LatticeOfAbsolutePeriodsBySage(Origami((1,2)(3,4), (2,3) ));
[ [ 2, 0 ], [ 0, 1 ] ]
</Example>
</Description>


<Func Name="OptimalDegreeBySage" Arg="origami"/>
<Returns>An Int.</Returns>
<Description>
	This function executes the SageMath method OptimalDegree to <Arg>origami</Arg> and returns its result as &GAP; object. The optimal degree of self is the degree of the map to the largest
   torus.
   Any origami <M>X \rightarrow T</M> factor as <M>i \circ \pi_{opt}</M> where i is an
   isogeny. The optimal degree is the degree of <M>\pi_{opt}</M>.

<Example>
gap> OptimalDegreeBySage(Origami((1,2)(3,4), (2,3) ));
2
</Example>
</Description>

<Func Name="PeriodGeneratorsBySage" Arg="origami"/>
<Returns>A list of lists of Ints.</Returns>
<Description>
	This function executes the SageMath method PeriodGenerators to <Arg>origami</Arg> and returns its result as &GAP; object. It return a list of periods that generate the lattice of periods.
<Example>
gap> PeriodGeneratorsBySage(Origami((1,3,6)(2,5,7)(4),(1,2,4,3,5,6,7) ));
[ [ 2, 0 ], [ 1, 0 ], [ 1, 0 ], [ 0, 2 ], [ -1, 2 ], [ 0, 1 ] ]
</Example>
</Description>

<Func Name="WidthsAndHeightsBySage" Arg="origami"/>
<Returns>A list of lists of Ints.</Returns>
<Description>
	This function executes the SageMath method WidthsAndHeights to <Arg>origami</Arg> and returns its result as &GAP; object. It return the list of widths and heigths of cylinder.
<Example>
gap> WidthsAndHeightsBySage(Origami((1,2)(3,4),(1,3,5,6)(2,4) ));
[ [ 1, 2 ], [ 2, 2 ] ]
</Example>
</Description>

<Func Name="SumOfLyapunovExponentsBySage" Arg="origami"/>
<Returns>A rational number.</Returns>
<Description>
	This function executes the SageMath method SumOfLyapunovExponents to <Arg>origami</Arg> and returns its result as &GAP; object.
 It returns the sum of Lyapunov exponents for this origami.
<Example>
gap> SumOfLyapunovExponentsBySage(Origami((1,2)(3,4),(2,3) ));
3/2
</Example>
</Description>


<Func Name="IntermediateCoversBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method NormalFormBySage to <Arg>origami</Arg> and returns its result as &GAP; object.
 It return the list of intermediate covers of this origami. Not implemented
</Description>
</ManSection>

</Section>
</Chapter>


<!-- #########################  -->
<!--  DATABASE DOCUMENTATION    -->
<!-- #########################  -->
<Chapter Label="DATABASE">
<Heading>The Origami Database</Heading>
Requires the <Package>ArangoDBInterface</Package> package and an ArangoDB installation.

TODO: setting up the database, where is the database file??

TODO: structure of the database


<ManSection>
  <Func Name="ConnectToOrigamiDB" Label="ConnectToOrigamiDB"/>
  <Returns>An <C>ArangoDatabase</C> object</Returns>
  <Description>
    Connects to the arango database 'origami' at the endpoint 'http+tcp://127.0.0.1:8529'
    with the user 'origami' and password 'secret'.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="InsertVeechGroupIntoDB" Label="InsertVeechGroupIntoDB" Arg="G"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Takes a <C>ModularSubgroup</C> <A>G</A> and inserts it into the Veech group table.
    Only precomputed attributes are inserted. This function does not compute anything
    new from the group.
    No test is performed to check whether <A>G</A> already exists in the database.
    The resulting <C>ArangoDocument</C> corresponding to the new database entry is returned.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="GetVeechGroupDBEntry" Label="GetVeechGroupDBEntry" Arg="G"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Takes a <C>ModularSubgroup</C> <A>G</A> and returns the corresponding
    database entry or <C>fail</C> if <A>G</A> is not in the database.
  </Description>
</ManSection>



<ManSection>
  <Oper Name="GetVeechGroupsFromDB" Label="GetVeechGroupsFromDB" Arg="constraints"/>
  <Returns>A list of <C>ModularSubgroup</C>s</Returns>
  <Description>
    Returns all Veech groups in the database subject to the argument <A>constraints</A>
    which is given in the form of a record.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> GetVeechGroupsFromDB(rec(index := 30, genus := 0));
  [list of modular subgroups]
  gap> GetVeechGroupsFromDB(rec(congruence := true, level := 12));
  [list of modular subgroups]
  gap> GetVeechGroupsFromDB(rec(deficiency := 5));
  [list of modular subgroups]
  ]]>
</Example>


<ManSection>
  <Oper Name="UpdateVeechGroupDBEntry" Label="UpdateVeechGroupDBEntry" Arg="G"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Updates the Veech group entry in the database with newly computed data and
    returns the corresponding <C>ArangoDocument</C>.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="RemoveVeechGroupFromDB" Label="RemoveVeechGroupFromDB" Arg="G"/>
  <Returns>Nothing.</Returns>
  <Description>
    Removes the Veech group <A>G</A> from the database (if present).
    NOT YET IMPLEMENTED
  </Description>
</ManSection>


<ManSection>
  <Oper Name="InsertOrigamiRepresentativeIntoDB" Label="InsertOrigamiRepresentativeIntoDB" Arg="O"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Inserts the normal form of the origami <A>O</A> into the origami representative
    list.
    Inserts only precomputed data. If the Veech group of <A>O</A> does not already
    exist in the database, it is also inserted.
    This function assumes that no other element of the <M>SL_2(\mathbb{Z})<M> orbit
    of <A>O</A> exists in the representative list, no test is performed to check this.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="GetOrigamiOrbitRepresentativeDBEntry" Label="GetOrigamiOrbitRepresentativeDBEntry" Arg="O"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Takes an Origami <A>O</A> and returns the corresponding database entry or
    <C>fail</C> if <A>O</A> is not in the database.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="GetOrigamiOrbitRepresentativesFromDB" Label="GetOrigamiOrbitRepresentativesFromDB" Arg="constraints"/>
  <Returns>A list of <C>Origami</C>s</Returns>
  <Description>
    Returns all origami orbit representatives in the database subject to the
    constraints given in the form of the record <A>constraints</A>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> GetOrigamiOrbitRepresentativesFromDB(rec(stratum := [4]));
  [ Origami((1,4,3)(2,5), (1,5,3,4)(2,6), 6) ]
  gap> GetOrigamiOrbitRepresentativesFromDB(rec(degree := 5));
  [ Origami((1,3,5), (1,3)(2,4,5), 5) ]
  ]]>
</Example>


<ManSection>
  <Oper Name="GetAllOrigamiOrbitRepresentativesFromDB" Label="GetAllOrigamiOrbitRepresentativesFromDB"/>
  <Returns>A list of <C>Origami</C>s</Returns>
  <Description>
    Returns all origami orbit representatives in the database.
    Shorthand for <C>GetOrigamiOrbitRepresentativesFromDB(rec());</C>
  </Description>
</ManSection>


<ManSection>
  <Oper Name="UpdateOrigamiOrbitRepresentativeDBEntry" Label="UpdateOrigamiOrbitRepresentativeDBEntry" Arg="O"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Updates the origami orbit representative entry in the database with newly
    computed data and returns the corresponding <C>ArangoDocument</C>.
    If the origami orbit representative <A>O</A> does not exist in the database,
    it is inserted.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="RemoveOrigamiOrbitRepresentativeFromDB" Label="RemoveOrigamiOrbitRepresentativeFromDB" Arg="O"/>
  <Returns>Nothing.</Returns>
  <Description>
    Removes the origami orbit representative <A>O</A> from the database if present.
    NOT YET IMPLEMENTED!
  </Description>
</ManSection>


<ManSection>
  <Oper Name="InsertOrigamiWithOrbitRepresentativeIntoDB" Label="InsertOrigamiWithOrbitRepresentativeIntoDB" Arg="O, R"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Inserts the origami <A>O</A> into the origami list with orbit representative
    <A>R</A> which is inserted into the origami orbit representative list if it is
    not already in there. Returns the <C>ArangoDocument</C> corresponding to <A>O</A>.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="InsertOrigamiIntoDB" Label="InsertOrigamiIntoDB" Arg="O"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Inserts an origami <A>O</A> into the database.
    If the Veech group and the orbit of <A>O</A> is known, this function checks if there is already a
    representative of the orbit of <A>O</A> in the database. If not, <A>O</A> is inserted as the
    representative of its orbit, if yes, <A>O</A> is only inserted into the origami
    list with a reference to the representative.
    If the Veech group of <A>O</A> is not known, it is inserted as its own representative.
    This might result in entries in the origami orbit representative list which are in the same
    orbit.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="GetOrigamiDBEntry" Label="GetOrigamiDBEntry" Arg="O"/>
  <Returns>An <C>ArangoDocument</C></Returns>
  <Description>
    Returns the <C>ArangoDocument</C> in the origami list corresponding to the
    origami <A>O</A> or fail if does not exist in the database.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="GetOrigamiOrbit" Label="GetOrigamiOrbit" Arg="O"/>
  <Returns>A list of <C>Origami</C>s</Returns>
  <Description>
    Returns all origamis in the database which are in the orbit of <A>O</A>.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="UpdateRepresentativeOfOrigami" Label="UpdateRepresentativeOfOrigami" Arg="O, R"/>
  <Returns>Nothing.</Returns>
  <Description>
    Updates the orbit representative of <A>O</A> to be <A>R</A>.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="RemoveOrigamiFromDB" Label="RemoveOrigamiFromDB" Arg="O"/>
  <Returns>Nothing.</Returns>
  <Description>
    Removes the origami <A>O</A> from the database.
  </Description>
</ManSection>


</Chapter>


</Body>
<Bibliography Databases="Origami"/>

<TheIndex/>

</Book>
