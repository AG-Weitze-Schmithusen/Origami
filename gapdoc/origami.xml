<?xml version="1.0" encoding="UTF-8"?>

<!--   The documentation for the origami package
-->

<!DOCTYPE Book SYSTEM "gapdoc.dtd">
<Book Name="Origami Package">

<TitlePage>
  <Title>The <Package>Origami</Package> Package</Title>
  <Subtitle>Computing Veechgroups of Origamis</Subtitle>
  <Date>13.11.2018</Date>
  <Version>Version 1.0.0</Version>
  <Author>Pascal Kattler
    <Email>kattler@math.uni-sb.de</Email>
    <Homepage>http://www.math.uni-sb.de/ag/weitze/</Homepage>
    <Address>
      AG Weitze-Schmithüsen<Br/>
      FR 6.1 Mathematik<Br/>
      Universität des Saarlandes<Br/>
      D-66041 Saarbrücken<Br/>
    </Address>

  </Author>
  <Author>Andrea Thevis
    <Email>thevis@math.uni-sb.de</Email>
    <Homepage>http://www.math.uni-sb.de/ag/weitze/</Homepage>
    <Address>
      AG Weitze-Schmithüsen<Br/>
      FR 6.1 Mathematik<Br/>
      Universität des Saarlandes<Br/>
      D-66041 Saarbrücken<Br/>
    </Address>
  </Author>

    <Copyright>&copyright; 2018 by Pascal Kattler
    </Copyright>

    <Acknowledgements>
We thank Sergio Siccha for his support and valuable input at the
beginning of this project. Further, we would like to thank Vincent
Delecroix and Samuel Lelièvre for fruitful discussions about algorithms
implemented in the surface_dynamics package in sage. Some of the
functionality of the surface_dynamics package can be used in this
package as well. For this we use an interface between GAP and sage. We
are thankful to Mohamed Barakat and Markus Pfeiffer for helping using
the interface. Moreover, we thank Thomas Breuer for helpful ideas and comments on some
algorithms implemented in this package.

      Supported by Project I.8 of SFB-TRR 195 'Symbolic Tools in Mathematics and
      their Application' of the German Research Foundation (DFG).
    </Acknowledgements>


  </TitlePage>

<TableOfContents/>

<Body>
  <Chapter> <Heading>The Veechgroup of Origamis </Heading>
    <Section Label="sec:theory"> <Heading>Introduction</Heading>
    This package provides calculations with origamis. An origami (also known as square-tiled surface) is a finite covering of a torus
    which is ramified at most over one point. It can be described in the following way from
    two permutations <M>\sigma_x, \sigma_y \in S_d</M>. We take <M>d</M> squares <M>Q_1, \dots, Q_d</M> and glue the lower side of
    <M>Q_i</M> to the upper side of <M>Q_{\sigma_y(i)}</M> and the right side of <M>Q_i</M> to the left side of <M>Q_{\sigma_x(i)}</M>.
    We require origamis to be connected and thus the group generated by <M>\sigma_x</M> and <M>\sigma_y</M>  acts transitively on <M>\{1,\dots,d\}</M>.
    In this package we identify an origami with a pair of permutations, which acts transitively on <M>\{1, \dots, d\}</M> up
    to simultaneous conjugation. We introduce a new type of origamis, namely origami objects, which are created
    by this two permutations and its degree. The degree of an origami is the number of squares. Origamis are stored as such objects.



    We are mainly interested in the Veechgroup of an origami. It can be shown that the Veechgroup of an origami is
    a subgroup of <M>SL_2(\mathbb{Z})</M> of finite index. So we fix two generators of <M>SL_2(\mathbb{Z})</M>
    <Display>
      S =
     \left( {\begin{array}{cc}
      0 &amp; -1 \\
      1 &amp; 0 \\
     \end{array} } \right)
   </Display>

    and

    <Display>
      T =
     \left( {\begin{array}{cc}
      1 &amp; 1 \\
      0 &amp; 1 \\
     \end{array} } \right).
   </Display>
 </Section>

 <Section> <Heading> The Free Group </Heading>
    In this package we fix the free group <M>F</M> generated by <M>\tilde{S}</M> and <M>\tilde{T}</M>.
    We consider the canonical epimorphism <M>\pi: F\to SL_2(\mathbb{Z})</M> with <M>\pi(\tilde{S})=S</M> and <M>\pi(\tilde{T})=T</M>.

    </Section>

    <Section> <Heading>The Origami Object</Heading>
      In this section we describe the main functions of this package.
      <ManSection>

        <Func Name="Origami" Arg="permX , permy, d"/>
        <Description>
		This function generates a new origami object with <M> \sigma_x =</M> <Arg> permX </Arg>, <M> \sigma_y =</M> <Arg> permY </Arg> and degree <Arg>d</Arg>.
        <Example>
gap> Origami((1,2), (2,3), 3);
Origami((1,2), (2,3), 3)
        </Example>
        </Description>

        <Func Name="OrigamiWithoutTest" Arg="permX , permy, d"/>
        <Description>
		This function does the same as <Ref Func="Origami"/>, but in contrast it does not test, weather the origami describes a connected surface.
        </Description>

	<Oper Name = "ActionOfSpecialLinearGroup" Arg="matrix, origami"/>
	<Description>
	The group <M>SL_2(\mathbb{Z}) </M> acts on the set of origamis of fixed degree. The follwoing methods for this operation are installed.
	</Description>


<Meth Name="ActionOfSpecialLinearGroup" Arg="word, origami"/>
        <Description>
          Given a word <Arg>word</Arg> in the free group  <M>Group(\tilde{S}, \tilde{T})</M> this function computes
          <M>\pi(<Arg>word</Arg>) \in SL_2(\mathbb{Z})</M> and returns <M>\pi(<Arg>word</Arg>).<Arg>origami</Arg></M>. The word is given
          as a string, as shown in the following example.
<Example>
gap> ActionOfSpecialLinearGroup("ST",Origami((1,3,5), (1,3)(2,4,5), 5));
Origami((1,3)(2,5,4), (2,4,5,3), 5)
</Example>
        </Description>

        <Meth Name="ActionOfSpecialLinearGroup" Arg="matrix, origami"/>
        <Description>
          Given matrix in <M>SL_2(\mathbb{Z}) </M> this function returns <Arg>matrix</Arg>.<Arg>origami</Arg>. The word is given
          as a string, as shown in the following example.
<Example>
gap> ActionOfSpecialLinearGroup([ [ 0, -1 ], [ 1, 1 ] ], Origami((1,3,5), 
>(1,3)(2,4,5), 5)); 
Origami((1,3)(2,5,4), (2,4,5,3), 5)
</Example>
        </Description>

<Func Name="ActionOfF2ViaCanonical" Arg="origami, word"/>
<Description>
 Given a word <Arg>word</Arg> in the free group  <M>Group(\tilde{S}, \tilde{T})</M> this function computes
 <M>\pi(<Arg>word</Arg>) \in SL_2(\mathbb{Z})</M> and returns <M>\pi(<Arg>word</Arg>).<Arg>origami</Arg></M>.
 But in contrast to <Ref Func="ActionOfSpecialLinearGroup"/> the result is stored in the canonical representation.
 ATTENTION: the order of arguments is switched compared to the order of the arguments in the function <Ref Func="ActionOfSpecialLinearGroup"/>.
  <Example>
gap> ActionOfF2ViaCanonical(Origami((1,2), (1,3), 3), "S");
Origami((1,2), (2,3), 3)
  </Example>
</Description>

<Func Name="RightActionOfF2ViaCanonical" Arg="origami, word"/>
<Description>
  This function computes the right action of the projection of a word <Arg>word</Arg> in the free group <M>Group(\tilde{S}, \tilde{T})</M> on an origami <Arg>origami</Arg>.
 It returns <M><Arg>origami</Arg>.\pi(<Arg>word</Arg>) = \pi(<Arg>word</Arg>)^-1.<Arg>origami</Arg></M>, where the left action
 is the common action of <M>SL_2(\mathbb{Z})</M> on origamis of a given degree. This action has
 the same orbits as the left action. For the Veechgroup computation both actions
 can be used and give the same result. In contrast to
 <Ref Func="ActionOfSpecialLinearGroup" /> the result is stored in the canonical representation.
 ATTENTION: the order of arguments is switched compared to the order of the arguments in the function <Ref Func="ActionOfSpecialLinearGroup" />.
 <Example>
gap> RightActionOfF2ViaCanonical(Origami((2,3), (1,3,2), 3),"T");
Origami((1,2), (2,3), 3)
</Example>
</Description>

<Func Name="OrigamiNormalForm" Arg="origami"/>
<Description>
          This function calculates a canonical representation of <Arg> origami</Arg>. Two origamis are equivaent, if they have the same canonical representation. This function has been implemented by Luca Junk and the algorithm is from <Cite Key = "ONF" />.
<Example>
gap> OrigamiNormalForm(Origami((1,3,5,7)(2,8,4,10)(6,9), (1,5,2,6,3)(4,10)(7,9) ));
Origami((1,2)(3,5,4,6)(7,8,9,10), (1,3)(2,4,5,6,7)(9,10), 10)
</Example>
</Description>

<!--
<Func Name="CanonicalOrigami" Arg="origami"/>
<Description>
    This function calculates a different canonical representation of an origami.
          Two origamis are equal if they are described by the same permutations in their
          canonical representation. This is an older slower Version.
<Example>
gap> CanonicalOrigami(Origami((1,10,7,6,8,9,2)(4,5), (1,8,5,4)(2,10,6)(3,9,7), 10));
Origami((1,2)(3,4,5,6,7,8,9), (1,2,3,7)(4,6,9)(5,10,8), 10)
</Example>

</Description>-->

        <Fam Name="OrigamiFamily"/>
        <Description>
          Since origamis do not fit in any existing family in &GAP;, we introduce a new family for origami objects called OrigamiFamily.
        </Description>

        <Attr Name="HorizontalPerm" Arg="origami"/>
        <Description>
           This function returns the horizontal permutation <M>\sigma_y</M> of an origami <Arg>origami</Arg>.
<Example>
gap> HorizontalPerm(Origami((1,3,5), (1,3)(2,4,5), 5));
(1,3,5)
</Example>
        </Description>

        <Attr Name="VerticalPerm" Arg="origami"/>
        <Description>
            This function returns the vertical permutation <M>\sigma_x</M> of an origami <Arg>origami</Arg>.
<Example>
gap> VerticalPerm( Origami((1,3,5), (1,3)(2,4,5), 5));
(1,3)(2,4,5)
</Example>
        </Description>

        <Attr Name="DegreeOrigami" Arg="origami"/>
        <Description>
        This function returns the degree of an <Arg>origami</Arg>.
<Example>
gap> DegreeOrigami(Origami((1,3,5), (1,3)(2,4,5), 5));
5
</Example>
        </Description>

        <Attr Name="Stratum" Arg="origami"/>
        <Description>
           This function calculates the stratum of an origami <Arg>origami</Arg>. The stratum of an origami is a list of the nonzero degrees
           of the singularities. For a singularity with cone angle <M>2\pi k</M> the degree of the singularity is <M>k-1</M>.
<Example>
gap> Stratum(Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8));
[ 1, 5 ]
</Example>
        </Description>

        <Attr Name="Genus" Arg="origami"/>
        <Description>
         This function calculates the genus of the origami surface.
<Example>
gap> Genus( Origami((1,2,3,4),(1,2)(3,4), 4) );
2
</Example>
        </Description>

        <Attr Name="VeechGroup" Arg="origami"/>
        <Description>
           This function calculates the Veechgroup of an origami <Arg>origami</Arg>. The Veechgroup <M>G</M> of <Arg>origami</Arg> is a subgroup
           <M>SL_2(\mathbb{Z})</M> of finite index. The group is stored as a ModularSubgroup from the <Package>ModularSubgroup</Package>
           package. It is represented by two permutations <M>\sigma_S</M> and <M>\sigma_T</M> describing how the generators
           <M>S</M> and <M>T</M> of <M>SL_2(\mathbb{Z})</M> act on the cosets of <M>G</M> in <M>SL_2(\mathbb{Z})</M>.
           E.g, if <M>SH_i = H_j</M> and <M>H_i,H_j</M> are the cosets associated to the integers <M>i,j</M>, respectively, then
           <M>\sigma_S(i)=j</M>.

           The algorithm was introduced by Gabriela Weitze-Schmithüsen in <Cite Key="MR2118271"/>.

           You get the coset permutations using the <Package>ModularSubgroup</Package> package as in the following example.
        <Example>
gap> SAction(VeechGroup(Origami((1,2,5)(3,4,6), (1,2)(5,6), 6)));
(1,3)(2,5)(4,7)(6,8)(9,10)
gap> TAction(VeechGroup(Origami((1,2,5)(3,4,6), (1,2)(5,6), 6)));
(1,2,4)(3,6)(5,8,7,9,10)
        </Example>
        </Description>

        <Attr Name="Cosets" Arg="origami"/>
        <Description>
           This function calculates the right cosets of the Veechgroup of an origami <Arg>origami</Arg> as a list of words in <M>S</M>
           and <M>T</M>.
<Example>
gap> Cosets(Origami((1,2,5)(3,4,6), (1,2)(5,6), 6));
[ &lt;identity ...>, S, T, T^-1, S*T, S*T^-1, T*S, T^-1*S, S*T*S, S*T^-1*S ]
</Example>
        </Description>

        <Func Name="EquivalentOrigami" Arg="origami1, origami2"/>
        <Description>
          This function tests whether <Arg>origami1</Arg> is equal  to <Arg>origami2</Arg> up to renumbering of the squares.
<Example>
gap> EquivalentOrigami(Origami((1,4)(2,6,3), (1,5)(2,3,6,4), 6), Origami((1,4,3)
>(2,5), (1,5,3,4)(2,6), 6));
true

gap> EquivalentOrigami(Origami((1,4)(2,6,3), (1,5)(2,3,6,4), 6), Origami((1,2,5)
>(3,4,6), (1,2)(5,6), 6));
false
</Example>
        </Description>
</ManSection>
</Section>
<Section> <Heading>List of Origamis</Heading>
The following functions generarte lists of Origamis. 
<ManSection>
<Func Name="OrigamiList" Arg="d"/>
<Description>
	This Function calculates a list of all origamis, with a given degree <Arg>d</Arg>. 
<Example>
gap> OrigamiList(2);
[ Origami((), (1,2), 2), Origami((1,2), (), 2), Origami((1,2), (1,2), 2) ]
</Example>
</Description>


<Func Name="OrigamiListWithStratum" Arg="d, stratum"/>
<Description>
	This function calculates a list of all origamis with a given degree <Arg>d</Arg> and stratum <Arg>stratum</Arg>.
<Example>
gap> OrigamiListWithStratum(5, [1,1]);
[ Origami((1,2), (1,3)(2,4,5), 5), Origami((1,2), (1,3,2,4,5), 5), 
  Origami((1,2,3), (1,2)(3,4,5), 5), Origami((1,2,3), (2,3,4,5), 5), 
  Origami((1,2,3), (2,4,5,3), 5), Origami((1,2)(3,4,5), (2,3), 5), 
  Origami((1,2)(3,4,5), (1,2,3), 5), Origami((1,2)(3,4,5), (2,3,4,5), 5), 
  Origami((1,2)(3,4,5), (2,3,5,4), 5), Origami((1,2)(3,4,5), (1,2,3,4,5), 5), 
  Origami((1,2)(3,4,5), (1,2,3,5,4), 5), Origami((1,2,3,4), (3,4,5), 5), 
  Origami((1,2,3,4), (3,5,4), 5), Origami((1,2,3,4), (1,2,3)(4,5), 5), 
  Origami((1,2,3,4), (1,3,2)(4,5), 5), Origami((1,2,3,4), (2,3,4,5), 5), 
  Origami((1,2,3,4), (2,5,4,3), 5), Origami((1,2,3,4), (1,2,4,5,3), 5), 
  Origami((1,2,3,4), (1,3,5,4,2), 5), Origami((1,2,3,4,5), (3,5), 5), 
  Origami((1,2,3,4,5), (1,2)(3,4,5), 5), Origami((1,2,3,4,5), (1,2)(3,5,4), 5)
    , Origami((1,2,3,4,5), (2,4,3,5), 5), Origami((1,2,3,4,5), (2,5,3,4), 5) ]
</Example>
</Description>
</ManSection>
</Section>
<Section> <Heading> Using SageMath functions</Heading>
The SageMath Package surface_dynamics from Vincent Delecroix <Cite Key="Delecroix"/> provides methods for origamis.
To use the functions of this chapter, Sage must be installed on your operation system. The following descriptions and examples are mainly taken from the manual of <Cite Key="Delecroix"/>.
<ManSection>
<Func Name="VeechgroupBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method veech_group to <Arg>origami</Arg> and returns its result as &GAP; object. It does the same as <Ref Func="VeechGroup"/>.
<Example>
gap> VeechgroupBySage(Origami((1,3,5), (1,3)(2,4,5), 5));
&lt;modular subgroup of index 24>

</Example>
</Description>

<Func Name="NormalFormBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method to_standard_form to <Arg>origami</Arg> and returns its result as &GAP; object. In principle it makes the same as <Ref Func="OrigamiNormalForm"/>, but it has an other representation.
<Example>
gap> NormalFormBySage(Origami((1,3,5), (1,3)(2,4,5), 5));
Origami((3,4,5), (1,2,3)(4,5), 5)
</Example>
</Description>
<Func Name="IsHyperellipticBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method IsHyperelliptic to <Arg>origami</Arg> and returns its result as &GAP; object. It tests, weather <Arg>origami</Arg> is hyperelliptic.
<Example>
gap> IsHyperellipticBySage(Origami((1,3), (1,2), 3));                                                                                           
true
</Example>
</Description>

<Func Name="IsPrimitiveBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method IsPrimitive to <Arg>origami</Arg> and returns its result as &GAP; object.    An origami is primitive if it does not cover an other origami.
	An origami is primitive if the action of the monodromy group has no
   non trivial block.
<Example>
gap> IsPrimitiveBySage(Origami((1,3), (1,2),3));
true
gap> IsPrimitiveBySage(Origami((1,2)(3,4), (1,3,5,6)(2,4), 6));
false
</Example>
</Description>

<Func Name="ReduceBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method Reduce to <Arg>origami</Arg> and returns its result as &GAP; object. It returns a reduced origami isomorphic (up to <M>SL(2,\mathbb{Q})</M> action) to that origami.
<Example>
gap> ReduceBySage(Origami((1,2)(3,4), (1,3,5,6)(2,4), 6));
Origami((1,2), (1,3), 6)
</Example>
</Description>

<Func Name="AbsolutePeriodGeneratorsBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method AbsolutePeriodGenerators to <Arg>origami</Arg> and returns its result as &GAP; object. It return a generating set of the absolute periods of this origami.
	To each curve on an origami, we can associate its holonomy (that is
   an element of ZZ x ZZ). This function returns a generating
   set of the module generated by holonomies of closed curves.
<Example>
gap> AbsolutePeriodGeneratorsBySage(Origami((1,2,3,4)(5,6), (1,5)(2,6),6)); 
[ [ 2, 0 ], [ 2, 0 ], [ 0, 1 ], [ 0, 1 ] ]
</Example>
</Description>

<Func Name="LatticeOfAbsolutePeriodsBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method LatticeOfAbsolutePeriods to <Arg>origami</Arg> and returns its result as &GAP; object. It returns (a,t,u) where ((a,0),(t,u)) is a standard basis for the
   lattice of the absolute periods of self
	The lattice of periods of an origami is the sublattice of <M> \mathbb{Z}^2</M>
   generated by the holonomy vectors of its saddle connections. Any
   sublattice of ZZ^2 has a standard basis consisting of a horizontal
   vector (a,0) and a nonhorizontal vector (t,u), where a, t, u are
   integers satisfying 0 &lt; t &lt; a and 0 &lt; t.
<Example>
gap> LatticeOfAbsolutePeriodsBySage(Origami((1,2)(3,4), (2,3), 4));   
[ [ 2, 0 ], [ 0, 1 ] ]
</Example>
</Description>

<Func Name="LatticeOfQuotientsBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method LatticeOfQuotients to <Arg>origami</Arg> and returns its result as &GAP; object. It return the lattice of quotients of this origami.
The set of quotients of an origami contain a maximal element
   (itself) and a minimal element (the 1-torus). More generally, it is
   organised as a lattice. Not implemented.
<Example>

</Example>
</Description>

<Func Name="OptimalDegreeBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method OptimalDegree to <Arg>origami</Arg> and returns its result as &GAP; object. The optimal degree of self is the degree of the map to the largest
   torus.
   Any origami <M>X \rightarrow T</M> factor as <M>i \circ \pi_{opt}</M> where i is an
   isogeny. The optimal degree is the degree of <M>\pi_{opt}</M>.

<Example>
gap> OptimalDegreeBySage(Origami((1,2)(3,4), (2,3), 4));
2
</Example>
</Description>

<Func Name="PeriodGeneratorsBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method PeriodGenerators to <Arg>origami</Arg> and returns its result as &GAP; object. It return a list of periods that generate the lattice of periods.
<Example>
gap> PeriodGeneratorsBySage(Origami((1,3,6)(2,5,7)(4),(1,2,4,3,5,6,7),7));    
[ [ 2, 0 ], [ 1, 0 ], [ 1, 0 ], [ 0, 2 ], [ -1, 2 ], [ 0, 1 ] ]
</Example>
</Description>

<Func Name="WidthsAndHeightsBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method WidthsAndHeights to <Arg>origami</Arg> and returns its result as &GAP; object. It return the list of widths and heigths of cylinder.
<Example>
gap> WidthsAndHeightsBySage(Origami((1,2)(3,4),(1,3,5,6)(2,4),4));        
[ [ 1, 2 ], [ 2, 2 ] ]
</Example>
</Description>

<Func Name="SumOfLyapunovExponentsBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method SumOfLyapunovExponents to <Arg>origami</Arg> and returns its result as &GAP; object. It returns the sum of Lyapunov exponents for this origami.
<Example>
gap> SumOfLyapunovExponentsBySage(Origami((1,2)(3,4),(2,3),4));
3/2
</Example>
</Description>

<Func Name="LyapunovExponentsApproxBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method LyapunovExponentsApprox to <Arg>origami</Arg> and returns its result as &GAP; object. Not implemented.
<Example>

</Example>
</Description>

<Func Name="IntermediateCoversBySage" Arg="origami"/>
<Description>
	This function executes the SageMath method NormalFormBySage to <Arg>origami</Arg> and returns its result as &GAP; object. It return the list of intermediate covers of this origami. Not implemented
<Example>
</Example>
</Description>

        <!-- ToDo
        <Func Name="" Arg=""/>
        <Description>
        <Example>
        </Example>
        </Description>


DeclareGlobalFunction("ActionOfT");
DeclareGlobalFunction("ActionOfS");
DeclareGlobalFunction("ActionOfInvT");
DeclareGlobalFunction("ActionOfInvS");

DeclareGlobalFunction("CycleStructureFromPartition");
DeclareGlobalFunction("CanonicalPermFromCycleStructure");
DeclareGlobalFunction("CanonicalPermFromPartition");
DeclareGlobalFunction("CanonicalPerm");

DeclareGlobalFunction("IsConnectedOrigami");

DeclareGlobalFunction("AddHash");
DeclareGlobalFunction("ContainHash");
DeclareGlobalFunction("hashForPermutations");
DeclareGlobalFunction("hashForOrigamis");


DeclareCategory("IsOrigami", IsObject);


DeclareAttribute("indexOrigami", IsOrigami);


BindGlobal(
  "Origami", function(horizontal, vertical, d)
    local Obj, ori;
    ori:= rec(d := d, x := horizontal, y := vertical);
    Obj:= rec();

    ObjectifyWithAttributes( Obj, NewType(OrigamiFamily, IsOrigami and IsAttributeStoringRep) , HorizontalPerm, ori.x, VerticalPerm, ori.y, DegreeOrigami, d );
    return Obj;
  end
  );



#! @Arguments d
#! @Returns a random origami
#! @Description This creates a random origami of degree d.
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("ExampleOrigami");

#! @Arguments Origami
#! @Returns A list with tree entrys
#! @Description This function is used to calculate some attributes.
#!             It calculates the Veechgroup of a given origami and .
#!              the veechgroup is stored as ModularGroup Object from the ModularGroup package.
#!  			The cosets of the veechgroup is stored in a list of words in the generators S and T
#!  			of the matrix group Sl_2(Z).
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("CalcVeechGroup");

#! @Arguments Origami
#! @Returns A list with tree entrys
#! @Description This function is used to calculate some attributes.
#!             It calculates the Veechgroup of a given origami and .
#!              the veechgroup is stored as ModularGroup Object from the ModularGroup package.
#!  			The cosets of the veechgroup is stored in a list of words in the generators S and T
#!  			of the matrix group Sl_2(Z).
#!        In Contrast to CalcVeechGroup, this uses equivalent tests instead of canonical Origamis.
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("CalcVeechGroupViaEquivalentTest");

#! @Arguments Origami
#! @Returns A list with tree entrys
#! @Description This function is used to calculate some attributes.
#!             It calculates the Veechgroup of a given origami and .
#!              the veechgroup is stored as ModularGroup Object from the ModularGroup package.
#!  			The cosets of the veechgroup is stored in a list of words in the generators S and T
#!  			of the matrix group Sl_2(Z). In contrast to CalcVeechGroup, this uses hash tables to
#!				store Origamis.
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("CalcVeechGroupWithHashTables");

#! @Arguments Origami
#! @Returns true or false
#!Description This Function tests weather the veechgrouo of the origami is the full group $Sl_2(mathbb{Z})$. This can be much
#! faster than calculating the veechgroup and then check weather it is $Sl_2(mathbb{Z})$, in the case, that the Index of the
#! Veechgroup is large.
#! @ChapterInfo he Origami object, The Origami object
DeclareGlobalFunction("HasVeechGroupSl_2");

#! @Arguments Origami
#! @Returns record of the form rec(d := * , x := *, y := *)
#! Describtion This calculates a record representation for an origami object.
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("ToRec");


DeclareGlobalFunction("CalcOrigamiList");

DeclareGlobalFunction("CalcOrigamiListForx");

DeclareGlobalFunction("CalcOrigamiListWithSubroutine");

DeclareGlobalFunction("CalcOrigamiListExperiment");

DeclareGlobalFunction("CalcH1_1");

DeclareGlobalFunction("RepresentantsH1_1");

DeclareGlobalFunction("CalcListOfH1_1WithFullVeechGroup");



DeclareGlobalFunction("CalcMatrix");
DeclareGlobalFunction("DecompositionOfMatritToFreeGroup");
DeclareGlobalFunction("ToMatrix");
DeclareGlobalFunction("SameCoset");
DeclareGlobalFunction("ElemOfVeechGroup");
DeclareGlobalFunction("MatrixInVeechGroup");


BindGlobal("KinderzeichnungenFamily",NewFamily("Kinderzeichnug"));
DeclareCategory("IsKinderzeichnung", IsObject);

DeclareAttribute("PermX", IsKinderzeichnung);

DeclareAttribute("PermY", IsKinderzeichnung);

BindGlobal(
  "Kinderzeichnung", function(horizontal, vertical)
    local Obj, kind;
    kind:= rec( x := horizontal, y := vertical);
    Obj:= rec();

    ObjectifyWithAttributes( Obj, NewType(KinderzeichnungenFamily, IsKinderzeichnung and IsAttributeStoringRep) , PermX, kind.x, PermY, kind.y );
    return Obj;
  end
  );

DeclareGlobalFunction("KinderzeichnungenFromCuspsOfOrigami");




The action of Sl into a own sexćtion ?

        -->
      </ManSection>
    </Section>
  </Chapter>
</Body>

<Bibliography Databases="Origami"/>
<TheIndex/>

</Book>
