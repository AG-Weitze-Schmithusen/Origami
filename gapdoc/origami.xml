<?xml version="1.0" encoding="UTF-8"?>

<!--   The documentation for the origami package
-->

<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="Origami Package">

<TitlePage>
  <Title>The <Package>ThreeKPlusOne</Package> Package</Title>
  <Version>Version 1</Version>
  <Author>Pascal Kattler
    <Email>kattler@math.uni-sb.de</Email>
  </Author>

  <!--<Copyright>&copyright; 2000 The Author. <P/>
    You can do with this package what you want.<P/> Really.
  </Copyright>-->
</TitlePage>

<TableOfContents/>

<Body>
  <Chapter> <Heading>The <M>3k+1</M> Problem</Heading>
    <Section Label="sec:theory"> <Heading>Introduction</Heading>
    This package provides calculations with Origamis. An Origami can be obtained in the following way from
    two permutations <M>\sigma_a, \sigma_b \in S_d</M>. We take <M>d</M> Squares <M>Q_1, \dots, Q_d</M> and clue the lower side of
    <M>Q_i</M> to the upper side of <M>Q_{\sigma_y(i)}</M> and the right side of <M>Q_i</M> to the left side of <M>Q_{\sigma_x(i)}</M>.
    So in this Package we identify an Origami with a pair of permutations, witch acts transitive on <M>\{1 \dots d\}</M> up
    to simultan conjugation. We store an Origami as Origami object.


    We are mainly interested in the Veechgroup of an Origami. It can be shown that the Veechgroup of an Origami is
    a subgroup of <M>Sl_2(\mathbb{Z})</M> of finite index. So we fix two generators
    <Display>
      S =
     \left( {\begin{array}{cc}
      0 &amp; -1 \\
      1 &amp; 0 \\
     \end{array} } \right)
   </Display>

    and

    <Display>
      T =
     \left( {\begin{array}{cc}
      1 &amp; 1 \\
      0 &amp; 1 \\
     \end{array} } \right).
   </Display>
 </Section>

 <Section> <Heading> The Free Group </Heading>
    In this package we fix the Free Group <M>F</M> generated by <M>S</M> and <M>T</M>.

    </Section>

    <Section> <Heading>The Origmai Object</Heading>
      In this section we describe the main function of this package.
      <ManSection>
        <Func Name="ActionOfSl" Arg="word, Origami"/>
        <Description>
          This function lets act a word in the free group  <M>Group(S, T)</M> ,representing an element of <M>Sl_2
          (\mathbb{Z})</M> on an Origami and returns <M>word.Origami</M>.
<Example>
gap> ActionOfSl(S*T,Origami((1,3,5), (1,3)(2,4,5), 5));
Origami((1,3)(2,5,4), (2,4,5,3), 5)
</Example>
        </Description>
<Func Name="ActionOfF2ViaCanonical" Arg="Origami, word"/>
<Description>
This lets act a word in the free group <M>Group(S, T)</M>, representing an element of <M>Sl_2(\mathbb{Z})</M>, on an Origami and returns <M>word.Origami</M>.
 But in contrast to <Ref Func="ActionOfSl"/> the result is stored in the canonical representation.
 ATTENTION: the order of arguments is here reserved.
  <Example>
  gap> ActionOfF2ViaCanonical(Origami((1,2), (1,3), 3), S);
Origami((1,2), (2,3), 3)
  </Example>
</Description>

<Func Name="RightActionOfF2ViaCanonical" Arg="Origami, word"/>
<Description>
 	This lets act a word in the free group <M>Group(S, T)</M> on an Origami from right and returns <M>Origami.word = word^-1.Origami</M>, where the left action
 is the common action of <M>Sl_2(\mathbb{Z})</M> on 2 mannifolds. This action has the same Veechgroup and orbits as the left action. In contrast to
 <Ref Func="ActionOfSl" /> the result is stored in the canonical representation.
 ATTENTION: the order of arguments is here reserved.
 <Example>
gap> RightActionOfF2ViaCanonical(Origami((2,3), (1,3,2), 3),T);
Origami((1,2), (2,3), 3)
 </Example>
</Description>

<Func Name="CanonicalOrigamiViaDelecroixAndStart" Arg="Origami, start"/>
<Description>
          This calculates a canonical representation of an origami depending on a given number start (Between 1 and the degree of
        of the Origami). To determine a canonical numbering the algorithm starts at the square with number start and walks over the origami
        in a certain way and numbers the squares in the order, they are visited . First it walks in horizontal direction one loop. Then it walks
        one step up (in vertical direection) and then again a loop in horizontal direction. This wil be repeated until the vertical
        loop is complete or all squares have been visited. If there are unvisited squares, we continue with the smallest number (in
        the new numbering), that has not been in a vertical loop. An Origami is connected, so that number exists.
        Two origamis are equal if they are described by the same permutations in their
        canonical representation.
<Example>
gap> CanonicalOrigamiViaDelecroixAndStart(Origami((1,10,7,6,8,9,2)(4,5),
gap> (1,8,5,4)(2,10,6)(3,9,7), 10), 1);
Origami((1,2,3,4,5,6,7)(8,9), (1,5,8,9)(2,4,7)(3,10,6), 10)
</Example>
</Description>

<Func Name="CanonicalOrigamiViaDelecroix" Arg="Origami"/>
<Description> This calculates a canonical representation of an origami. It calculates the representation from CanonicalOrigamiViaDelecroixAndStart with
          several start squares, independent of the given representation. Then it takes the minimum with respect to some order.
    			Two origamis are equal if they are described by the same permutations in their
  				canonical representation.
<Example>
gap> CanonicalOrigamiViaDelecroix(Origami((1,10,7,6,8,9,2)(4,5), (1,8,5,4)(2,10,6)(3,9,7), 10));
Origami((2,3,4,5,6,7,8)(9,10), (1,2,6)(3,5,7)(4,8,9,10), 10)
</Example>
</Description>

<Func Name="CanonicalOrigami" Arg="Origami"/>
<Description>
    This calculates a canonical representation of an origami.
    			Two origamis are equal if they are described by the same permutations in their
  				canonical representation. This is an older slower Version.
<Example>
  gap> CanonicalOrigami(Origami((1,10,7,6,8,9,2)(4,5), (1,8,5,4)(2,10,6)(3,9,7), 10));
Origami((1,2)(3,4,5,6,7,8,9), (1,2,3,7)(4,6,9)(5,10,8), 10)
</Example>
</Description>

        <Fam Name="OrigamiFamily"/>
        <Description>
          The only sense of this Familiy is, that Origami does not fit in any other
        </Description>

        <Attr Name="HorizontalPerm" Arg="Origami"/>
        <Description>
           This returns the vertical permutation <M>\sigma_y</M> of the Origami.
        <Example>
          gap> HorizontalPerm(Origami((1,3,5), (1,3)(2,4,5), 5));
(1,3,5)
        </Example>
        </Description>

        <Attr Name="VerticalPerm" Arg="Origami"/>
        <Description>
            This returns the horizontal permutation <M>\sigma_x</M> of the Origami.
        <Example>
          gap> VerticalPerm( Origami((1,3,5), (1,3)(2,4,5), 5));
            (1,3)(2,4,5)
        </Example>
        </Description>

        <Attr Name="DegreeOrigami" Arg="Origami"/>
        <Description>
          This returns the degree of an Origami.
        <Example>
          gap> DegreeOrigami(Origami((1,3,5), (1,3)(2,4,5), 5));
5
        </Example>
        </Description>

        <Attr Name="Stratum" Arg="Origami"/>
        <Description>
           This calculates the stratum of an Origami. That is a list of the orders of the singularities
        <Example>
          gap> Stratum(Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8));
[ 1, 5 ]
        </Example>
        </Description>

        <Attr Name="Genus" Arg="Origami"/>
        <Description>
         This calculates the genus of the Origami surface.
        <Example>
          gap> Genus( Origami((1,2,3,4),(1,2)(3,4), 4) );
2
        </Example>
        </Description>

        <Attr Name="VeechGroup" Arg="Origami"/>
        <Description>
           This calculates the Veechgroup of an Origami. This is a subgroup of <M>Sl_2(\mathbb{Z})</M> of finite
            degree. The group is stored as ModularSubgroup from the <Package>ModularSubgroup</Package> package.
           The Veechgroup is represented as the coset permutations <M>\sigma_S</M>
           and <M>\sigma_T</M> with respect to the generators <M>S</M> and <M>T</M>. This means if <M>i</M>
            is the integer associated to the rigth coset <M>G</M> (Cosets( O ) [ i ] VeechGroup = H)
           then we have for the coset <M>H</M>, associated to <M>\sigma_S(i)</M>, that <M>SG = H</M>.
           Dito for <M>\sigma_T</M>.

           You get the coset Permutations from the ModularSubgroup like in the following Example.
        <Example>
gap> SAction(VeechGroup(Origami((1,2,5)(3,4,6), (1,2)(5,6), 6)));
(1,3)(2,5)(4,7)(6,8)(9,10)
gap> TAction(VeechGroup(Origami((1,2,5)(3,4,6), (1,2)(5,6), 6)));
(1,2,4)(3,6)(5,8,7,9,10)
        </Example>
        </Description>

        <Attr Name="Cosets" Arg="Origami"/>
        <Description>
           This Calculates the right cosets of the Veechgroup of an Origami as list of words in <M>S</M>
           and <M>T</M>.
        <Example>
          gap> Cosets(Origami((1,2,5)(3,4,6), (1,2)(5,6), 6));
[ &lt; identity ...>, T, S, T^2, T*S, S*T, T^2*S, T*S*T, T^2*S*T, T^2*S*T^2 ]
        </Example>
        </Description>

        <Func Name="" Arg="Origami1, Origami2"/>
        <Description>
          This tests wether Origami1 is equal up to Origami2 up to numbering of the squares.
        <Example>
gap> EquivalentOrigami(Origami((1,4)(2,6,3), (1,5)(2,3,6,4), 6), Origami((1,4,3)(2,5), (1,5,3,4)(2,6), 6));
true

gap> EquivalentOrigami(Origami((1,4)(2,6,3), (1,5)(2,3,6,4), 6), Origami((1,2,5)(3,4,6), (1,2)(5,6), 6));
false
        </Example>
        </Description>

        <!-- ToDo
        <Func Name="" Arg=""/>
        <Description>
        <Example>
        </Example>
        </Description>

DeclareGlobalFunction("ActionOfT");
DeclareGlobalFunction("ActionOfS");
DeclareGlobalFunction("ActionOfInvT");
DeclareGlobalFunction("ActionOfInvS");

DeclareGlobalFunction("CycleStructureFromPartition");
DeclareGlobalFunction("CanonicalPermFromCycleStructure");
DeclareGlobalFunction("CanonicalPermFromPartition");
DeclareGlobalFunction("CanonicalPerm");

DeclareGlobalFunction("IsConnectedOrigami");

DeclareGlobalFunction("AddHash");
DeclareGlobalFunction("ContainHash");
DeclareGlobalFunction("hashForPermutations");
DeclareGlobalFunction("hashForOrigamis");


DeclareCategory("IsOrigami", IsObject);


DeclareAttribute("indexOrigami", IsOrigami);


BindGlobal(
	"Origami", function(horizontal, vertical, d)
		local Obj, ori;
		ori:= rec(d := d, x := horizontal, y := vertical);
		Obj:= rec();

		ObjectifyWithAttributes( Obj, NewType(OrigamiFamily, IsOrigami and IsAttributeStoringRep) , HorizontalPerm, ori.x, VerticalPerm, ori.y, DegreeOrigami, d );
		return Obj;
	end
	);



#! @Arguments d
#! @Returns a random origami
#! @Description This creates a random origami of degree d.
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("ExampleOrigami");

#! @Arguments Origami
#! @Returns A list with tree entrys
#! @Description This function is used to calculate some attributes.
#!             It calculates the Veechgroup of a given origami and .
#!              the veechgroup is stored as ModularGroup Object from the ModularGroup package.
#!  			The cosets of the veechgroup is stored in a list of words in the generators S and T
#!  			of the matrix group Sl_2(Z).
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("CalcVeechGroup");

#! @Arguments Origami
#! @Returns A list with tree entrys
#! @Description This function is used to calculate some attributes.
#!             It calculates the Veechgroup of a given origami and .
#!              the veechgroup is stored as ModularGroup Object from the ModularGroup package.
#!  			The cosets of the veechgroup is stored in a list of words in the generators S and T
#!  			of the matrix group Sl_2(Z).
#!        In Contrast to CalcVeechGroup, this uses equivalent tests instead of canonical Origamis.
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("CalcVeechGroupViaEquivalentTest");

#! @Arguments Origami
#! @Returns A list with tree entrys
#! @Description This function is used to calculate some attributes.
#!             It calculates the Veechgroup of a given origami and .
#!              the veechgroup is stored as ModularGroup Object from the ModularGroup package.
#!  			The cosets of the veechgroup is stored in a list of words in the generators S and T
#!  			of the matrix group Sl_2(Z). In contrast to CalcVeechGroup, this uses hash tables to
#!				store Origamis.
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("CalcVeechGroupWithHashTables");

#! @Arguments Origami
#! @Returns true or false
#!Description This Function tests weather the veechgrouo of the origami is the full group $Sl_2(mathbb{Z})$. This can be much
#! faster than calculating the veechgroup and then check weather it is $Sl_2(mathbb{Z})$, in the case, that the Index of the
#! Veechgroup is large.
#! @ChapterInfo he Origami object, The Origami object
DeclareGlobalFunction("HasVeechGroupSl_2");

#! @Arguments Origami
#! @Returns record of the form rec(d := * , x := *, y := *)
#! Describtion This calculates a record representation for an origami object.
#! @ChapterInfo The Origami object, The Origami object
DeclareGlobalFunction("ToRec");


DeclareGlobalFunction("CalcOrigamiList");

DeclareGlobalFunction("CalcOrigamiListForx");

DeclareGlobalFunction("CalcOrigamiListWithSubroutine");

DeclareGlobalFunction("CalcOrigamiListExperiment");

DeclareGlobalFunction("CalcH1_1");

DeclareGlobalFunction("RepresentantsH1_1");

DeclareGlobalFunction("CalcListOfH1_1WithFullVeechGroup");



DeclareGlobalFunction("CalcMatrix");
DeclareGlobalFunction("DecompositionOfMatritToFreeGroup");
DeclareGlobalFunction("ToMatrix");
DeclareGlobalFunction("SameCoset");
DeclareGlobalFunction("ElemOfVeechGroup");
DeclareGlobalFunction("MatrixInVeechGroup");


BindGlobal("KinderzeichnungenFamily",NewFamily("Kinderzeichnug"));
DeclareCategory("IsKinderzeichnung", IsObject);

DeclareAttribute("PermX", IsKinderzeichnung);

DeclareAttribute("PermY", IsKinderzeichnung);

BindGlobal(
	"Kinderzeichnung", function(horizontal, vertical)
		local Obj, kind;
		kind:= rec( x := horizontal, y := vertical);
		Obj:= rec();

		ObjectifyWithAttributes( Obj, NewType(KinderzeichnungenFamily, IsKinderzeichnung and IsAttributeStoringRep) , PermX, kind.x, PermY, kind.y );
		return Obj;
	end
	);

DeclareGlobalFunction("KinderzeichnungenFromCuspsOfOrigami");




The action of Sl into a own sexćtion ?

        -->
      </ManSection>
    </Section>
  </Chapter>
</Body>

<!--<Bibliography Databases="3k+1" /> -->
<TheIndex/>

</Book>
