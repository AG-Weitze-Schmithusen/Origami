#! @Chapter Functions for Dessins d'enfants
#! @ChapterLabel Functions for Dessins d'enfants
#! This section lists all functions used for dessins d'enfants
#! @Section  Functions for Dessins d'enfants
BindGlobal("DessinFamily",NewFamily("Dessin"));
DeclareCategory("IsDessin", IsObject);

#! @Arguments D
#! @Returns A permutation
#! @Description
#! This returns the permutation $\sigma_0$ of the dessin that corresponds to the black vertices.
#! @BeginExampleSession
#! gap> D := Dessin((1,2,3), (2,3), 3);
#! Dessin((1,2,3), (2,3), 3)
#! gap> BlackPerm(D);
#! (1,2,3)
#! @EndExampleSession
DeclareAttribute("BlackPerm", IsDessin);

#! @Arguments D
#! @Returns A permutation
#! @Description
#! This returns the permutation $\sigma_1$ of the dessin that corresponds to the white vertices.
#!
#! @BeginExampleSession
#! gap> D := Dessin((1,2,3), (2,3), 3);
#! Dessin((1,2,3), (2,3) ,3)
#! gap> WhitePerm(D);
#! (2,3)
#! @EndExampleSession
DeclareAttribute("WhitePerm", IsDessin);

#! @Arguments D
#! @Returns A positive integer
#! @Description
#! This returns the degree of the dessin.
#!
#! @BeginExampleSession
#! gap> D := Dessin((1,2,3), (2,3), 3);
#! Dessin((1,2,3), (2,3), 3)
#! gap> DegreeDessin(D);
#! 3
#! @EndExampleSession
DeclareAttribute("DegreeDessin", IsDessin);

#! @Arguments black, white, d
#! @Returns A dessin
#! @Description
#! This function constructs a dessin object given by monodromy actions. We expect the dessin to be connected,
#! the permutations should act transitively on $\{1, \dots, d\}$.
#! @BeginExampleSession
#! gap> D := Dessin((1,2,3), (2,3), 3);
#! Dessin((1,2,3), (2,3), 3)
#! @EndExampleSession
DeclareOperation("Dessin", [IsPerm, IsPerm, IsPosInt]);


#! @Arguments D
#! @Returns A record
#! @Description
#! This function returns the valency list of a dessin.
#! It returns a record.
#! @BeginExampleSession
#! gap> D := Dessin((1,2,3), (2,3), 3);
#! Dessin((1,2,3), (2,3))
#! gap> ValencyList(D);
#! rec( black := [ 3 ], white := [ 1, 2 ] )
#! @EndExampleSession
DeclareAttribute("ValencyList", IsDessin);

#! @Arguments D
#! @Returns A non-negative integer
#! @Description
#! This function calculates the genus of the dessin (so the genus of the underlying closed Riemann surface.
#! @BeginExampleSession
#! gap> D := Dessin((1,2,3), (2,3), 3);
#! gap> Genus(D);
#! 0
#! @EndExampleSession
DeclareAttribute("Genus", IsDessin);

#! @Arguments D
#! @Returns A boolean
#! @Description
#! This checks whether the dessin is connected, so whether the group generated by $sigma_0$ and $sigma_1$ acts transitively on $\{1, \dots, \mathrm{deg}(D)\}$.
#! @BeginExampleSession
#! gap> D := Dessin((1,2,3), (2,3), 3);
#! Dessin((1,2,3), (2,3), 3)
#! gap> IsConnectedDessin(D);
#! true
#! @EndExampleSession
DeclareAttribute("IsConnectedDessin", IsDessin);


#! @Arguments D
#! @Returns A list
#! @Description
#! This function returns the connected components of the dessin.
#! @BeginExampleSession
#! gap> D := Dessin((1,2,3), (2,3), 3);
#! Dessin((1,2,3), (2,3), 3)
#! gap> ConnectedComponentsDessin(D);
#! [ Dessin((1,2,3), (2,3), 3) ]
#! @EndExampleSession
DeclareGlobalFunction("ConnectedComponentsDessin");


#! @Arguments O
#! @Returns A list
#! @Description
#! This function returns the stable graph of an origami. It returns a list of lists.
#! The first entry is a list of the genera of the connected components of the dessin of the origami.
#! The  second entry is the adjacency matrix of the origami graph.
#! @BeginExampleSession
#! gap> O := Origami((1,5,6,9,10)(3,4)(7,8)(11,12), (1,3,5,7,9,11)(2,4,10,12,6,8));
#! Origami((1,5,6,9,10)(3,4)(7,8)(11,12), (1,3,5,7,9,11)(2,4,10,12,6,8), 12)
#! gap> OrigamiGraph(O);
#! [ [ 1, 0 ], [ [ 0, 3 ], [ 2, 0 ] ] ]
#! @EndExampleSession
DeclareGlobalFunction("OrigamiGraph");

DeclareGlobalFunction("NormalDessinsForm");

DeclareGlobalFunction("DessinOfOrigami");

DeclareGlobalFunction("AllDessinsOfOrigami");