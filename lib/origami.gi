InstallMethod(
	Origami, [IsPerm, IsPerm], function(horizontal, vertical)
		local d;
		d :=  Maximum(LargestMovedPoint(horizontal), LargestMovedPoint(vertical)) - Minimum(SmallestMovedPoint(horizontal), SmallestMovedPoint(vertical)) + 1;
		if IsTransitive( Group(horizontal, vertical) ) = false 
			then Error("The described surface is not connected. The permutation group, generated by the two permutations, must act transitive on [1..d] ");
		fi;
		return OrigamiWithoutTest(horizontal, vertical, d);
	end
	);

InstallOtherMethod( Origami, [IsPerm, IsPerm, IsInt], function(horizontal, vertical, d)
		if IsTransitive( Group(horizontal, vertical) ) = false 
			then Error("The described surface is not connected. The permutation group, generated by the two permutations, must act transitive on [1..d] ");
		fi;
		return OrigamiWithoutTest(horizontal, vertical, d);
	end
	);


InstallGlobalFunction(
	OrigamiWithoutTest, function(horizontal, vertical, d)
		local Obj, ori;
		ori:= rec(d := d, x := horizontal, y := vertical);
		Obj:= rec();

		ObjectifyWithAttributes( Obj, NewType(OrigamiFamily, IsOrigami and IsAttributeStoringRep) , HorizontalPerm, ori.x, VerticalPerm, ori.y, DegreeOrigami, d );
		return Obj;
	end
	);


InstallMethod(String, [IsOrigami], function(Origami)
	return Concatenation("Origami(", String(HorizontalPerm(Origami)), ", ", String(VerticalPerm(Origami)), ", ", String(DegreeOrigami(Origami)), ")");
	end
);

InstallMethod(\=, [IsOrigami, IsOrigami], function(O1, O2)
	return (VerticalPerm(O1) = VerticalPerm(O2)) and (HorizontalPerm(O1) = HorizontalPerm(O2));
	end
);

# determines an random origami of a given degree
# INPUT degree d
# OUTPUT a random origami of degree d
InstallGlobalFunction(ExampleOrigami, function (d)
	local x, y;
	repeat
		x:=PseudoRandom(SymmetricGroup(d));
		y:=PseudoRandom(SymmetricGroup(d));
	until IsTransitive(Group(x,y), [1..d]);
	return Origami(x, y, d);
end);

InstallGlobalFunction(IsConnectedOrigami, function(origami)
	return IsTransitive(Group(HorizontalPerm(origami), VerticalPerm(origami)), [1..DegreeOrigami(origami)]);
end);





InstallGlobalFunction(CalcVeechGroupWithHashTables, function(O)
	local NewOrigamiList, newOrigamis, sigma, HelpCalc, foundM, W, canonicalOrigamiList, i, j,
	 				counter, HelpO;
	counter := 1;
	sigma:=[[],[]];
	canonicalOrigamiList := [];
	HelpO := CanonicalOrigami(O);
	SetindexOrigami (HelpO, 1);
	#AddHash(canonicalOrigamiList, HelpO,  hashForOrigamis);
	HelpCalc := function(GlList)
		NewOrigamiList := [];
		for W in GlList do
			newOrigamis := [OrigamiNormalForm(ActionOfT(W)), OrigamiNormalForm(ActionOfS(W))];
			for j in [1, 2] do
				 #M = newOrigamis[
				i := ContainHash(canonicalOrigamiList, newOrigamis[j], hashForOrigamis);
				if i = 0 then foundM := false; else foundM := true; fi;
				if foundM then
					sigma[j][indexOrigami(W)] := i;
				fi;
				if foundM = false then
					SetindexOrigami(newOrigamis[j], counter);
					AddHash(canonicalOrigamiList, newOrigamis[j], hashForOrigamis);
					Add(NewOrigamiList, newOrigamis[j]);
					sigma[j][indexOrigami(W)] := counter;
					counter := counter + 1;
				fi;
			od;
		od;
		if Length(NewOrigamiList) > 0 then HelpCalc(NewOrigamiList); fi;
	end;
	HelpCalc([HelpO]);
	return ModularSubgroup(PermList(sigma[2]), PermList(sigma[1]));
end);



InstallMethod(Genus, "for a origami", [IsOrigami], function(Origami)
	local s, i, e;
	e := 0;
	s := Stratum(Origami);
	for i in s do
		e := e + i;
	od;
	return ( e + 2 ) / 2;
end);

InstallMethod(VeechGroup, "for a origami", [IsOrigami], function(Origami)
	return CalcVeechGroupWithHashTables(Origami);
end);

InstallMethod(Cosets, "for a origami", [IsOrigami], function(Origami)
	return RightCosetRepresentatives(VeechGroup(Origami));
end);


#This function calculates the Stratum of an given Origami
#INPUT: An Origami O
#OUTPUT: The Stratum of the Origami as List of Integers.
InstallMethod(Stratum,"for a origami", [IsOrigami], function(O)
	local com, Stratum, CycleStructure, current,i, j;
	com:=HorizontalPerm(O)* VerticalPerm(O) * HorizontalPerm(O)^(-1) * VerticalPerm(O)^(-1);
	CycleStructure:= CycleStructurePerm(com);
	Stratum:=[];
	for i in [1..Length(CycleStructure)] do
		if IsBound(CycleStructure[i]) then
			for j in [1..CycleStructure[i]] do
				Add(Stratum, i);
			od;
		fi;
	od;
	return AsSortedList( Stratum);
end);


InstallGlobalFunction( EquivalentOrigami, function(O1, O2)
	if RepresentativeAction(SymmetricGroup(DegreeOrigami(O1)), [HorizontalPerm(O1), VerticalPerm(O1)],
																			[HorizontalPerm(O2), VerticalPerm(O2)], OnTuples) = fail
		 then return false;
	else
		return true;
	fi;
end
);

InstallGlobalFunction(HasVeechGroupSl_2, function(O)
	if EquivalentOrigami( O, ActionOfS(O) ) then
		if EquivalentOrigami( O, ActionOfT(O)) then
			return true;
		fi;
	fi;
	return false;
end
);
