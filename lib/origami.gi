InstallMethod(
	Origami, [IsPerm, IsPerm], function(horizontal, vertical)
		local d;
		d :=  Maximum(LargestMovedPoint(horizontal), LargestMovedPoint(vertical));
		if d = 0 then d := 1; fi;
		if IsTransitive( Group(horizontal, vertical) ) = false then
			Error("The described surface is not connected. The permutation group, generated by the two permutations, must act transitively on {1,...,d}.");
		fi;
		return OrigamiNC(horizontal, vertical, d);
	end
	);

InstallOtherMethod( Origami, [IsPerm, IsPerm, IsInt], function(horizontal, vertical, d)
		if IsTransitive( Group(horizontal, vertical) ) = false then
			Error("The described surface is not connected. The permutation group, generated by the two permutations, must act transitively on {1,...,d}.");
		fi;
		return OrigamiNC(horizontal, vertical, d);
	end
	);


InstallGlobalFunction(
	OrigamiNC, function(horizontal, vertical, d)
		local Obj, ori;
		ori:= rec(d := d, x := horizontal, y := vertical);
		Obj:= rec();

		ObjectifyWithAttributes( Obj, NewType(OrigamiFamily, IsOrigami and IsAttributeStoringRep) , HorizontalPerm, ori.x, VerticalPerm, ori.y, DegreeOrigami, d );
		return Obj;
	end
	);


InstallMethod(String, [IsOrigami], function(Origami)
	return Concatenation("Origami(", String(HorizontalPerm(Origami)), ", ", String(VerticalPerm(Origami)), ", ", String(DegreeOrigami(Origami)), ")");
	end
);

InstallMethod( DisplayString, [IsOrigami], function( origami )
	local s;
	s := Concatenation(String( origami ), "\n", "horizontal permutation = ", String(HorizontalPerm(origami)), "\n", "vertical permutation = ", String(VerticalPerm(origami)), "\n", "Genus = ", 			String( Genus( origami ) ), "\n", "Stratum = ", String( Stratum( origami ) ) );
	return s;
end);

InstallMethod(ViewString, [IsOrigami], function( origami )
	return String( origami );
end);

InstallMethod(PrintString, [IsOrigami], function( origami )
	return String( origami );
end);

InstallMethod(\=, [IsOrigami, IsOrigami], function(O1, O2)
	return (VerticalPerm(O1) = VerticalPerm(O2)) and (HorizontalPerm(O1) = HorizontalPerm(O2));
	end
);


InstallMethod(\<, [IsOrigami, IsOrigami], function(o1, o2)
	if HorizontalPerm(o1) >  HorizontalPerm (o1) then return true;
		else if HorizontalPerm(o1) <  HorizontalPerm (o1) then return false; else return VerticalPerm(o1) < VerticalPerm(o2);fi;
		fi;
end);



# This method specifies the hash key for origamis
InstallMethod(SparseIntKey, [IsObject, IsOrigami], function( b , origami )
	local HashForOrigami;
	HashForOrigami := function( origami )
    	return (hashForPermutations( HorizontalPerm(origami) ) + hashForPermutations( VerticalPerm(origami) ));
	end;
	return HashForOrigami;
end);







#This function calculates the coset Graph of the Veech group of an given Origami O
#INPUT: An origami O
#OUTPUT: The coset Graph as Permutations sigma_S and Sigma_T
InstallGlobalFunction(CalcVeechGroup, function(O)
	local  sigma, HelpCalc, D, foundM, W, NewOrigamiPositions, canonicalOrigamiList, i, j, newOrigamis;
	sigma:=[[],[]];
	canonicalOrigamiList := [OrigamiNormalForm(O)];
	HelpCalc := function(GlList)
		NewOrigamiPositions := [];
		for W in GlList do
			newOrigamis := [OrigamiNormalForm( ActionOfT(W) ), OrigamiNormalForm( ActionOfS(W) )];
			for j in [1, 2] do
				foundM := false;
				for i in [1..Length(canonicalOrigamiList)] do
					if canonicalOrigamiList[i] = newOrigamis[j] then
						foundM := true;
						sigma[j][Position(canonicalOrigamiList, W)] := i;
						break;
					fi;
				od;
				if foundM = false then
					Add(canonicalOrigamiList, newOrigamis[j]);
					Add(NewOrigamiPositions, newOrigamis[j]);
					sigma[j][Position(canonicalOrigamiList, W)] := Length(canonicalOrigamiList);  # = Length(Rep) -1 ?
				fi;
			od;
		od;
		if Length(NewOrigamiPositions) > 0 then HelpCalc(NewOrigamiPositions); fi;
	end;
	HelpCalc([OrigamiNormalForm(O)]);
	return [ModularSubgroup(PermList(sigma[2]), PermList(sigma[1]))];
end);


InstallGlobalFunction(CalcVeechGroupWithHashTables, function(O)
	local NewOrigamiList, newOrigamis, sigma, HelpCalc, foundM, W, canonicalOrigamiList, i, j,
	 				counter, HelpO;
	counter := 1;
	sigma:=[[],[]];
	canonicalOrigamiList := [];
	HelpO := OrigamiNormalForm(O);
	SetindexOrigami (HelpO, 1);
	#AddHash(canonicalOrigamiList, HelpO,  hashForOrigamis);
	HelpCalc := function(GlList)
		NewOrigamiList := [];
		for W in GlList do
			newOrigamis := [OrigamiNormalForm(ActionOfT(W)), OrigamiNormalForm(ActionOfS(W))];
			for j in [1, 2] do
				 #M = newOrigamis[
				i := ContainHash( canonicalOrigamiList, newOrigamis[j], hashForOrigamis );
				if i = 0 then foundM := false; else foundM := true; fi;
				if foundM then
					sigma[j][indexOrigami(W)] := i;
				fi;
				if foundM = false then
					SetindexOrigami(newOrigamis[j], counter);
					AddHash(canonicalOrigamiList, newOrigamis[j], hashForOrigamis);
					Add(NewOrigamiList, newOrigamis[j]);
					sigma[j][indexOrigami(W)] := counter;
					counter := counter + 1;
				fi;
			od;
		od;
		if Length(NewOrigamiList) > 0 then HelpCalc(NewOrigamiList); fi;
	end;
	HelpCalc([HelpO]);
	return ModularSubgroup(PermList(sigma[2]), PermList(sigma[1]));
end);


InstallGlobalFunction(CalcVeechGroupWithHashTablesOld, function(O)
	local NewOrigamiList, newOrigamis, sigma, HelpCalc, foundM, W, canonicalOrigamiList, i, j,
	 				counter, HelpO;
	counter := 2;
	sigma:=[[],[]];
	canonicalOrigamiList := SparseHashTable();
	HelpO := OrigamiNormalForm(O);
	AddDictionary( canonicalOrigamiList, HelpO, 1 );
	HelpCalc := function(GlList)
		NewOrigamiList := [];
		for W in GlList do
			newOrigamis := [OrigamiNormalForm(ActionOfT(W)), OrigamiNormalForm(ActionOfS(W))];
			for j in [1, 2] do
				i := LookupDictionary(canonicalOrigamiList, newOrigamis[j]);
				if i = fail then foundM := false; else foundM := true; fi;
				if foundM then
					sigma[j][LookupDictionary(canonicalOrigamiList, W) ] := i;
				fi;
				if foundM = false then
					AddDictionary( canonicalOrigamiList, newOrigamis[j], counter  );
					Add(NewOrigamiList, newOrigamis[j]);
					sigma[j][ LookupDictionary(canonicalOrigamiList, W) ] := counter;
					counter := counter + 1;
				fi;
			od;
		od;
		if Length(NewOrigamiList) > 0 then HelpCalc(NewOrigamiList); fi;
	end;
	HelpCalc([HelpO]);
	return ModularSubgroup(PermList(sigma[2]), PermList(sigma[1]));
end);




InstallMethod(Genus, "for a origami", [IsOrigami], function(Origami)
	local s, i, e;
	e := 0;
	s := Stratum(Origami);
	for i in s do
		e := e + i;
	od;
	return ( e + 2 ) / 2;
end);

InstallMethod(VeechGroup, "for a origami", [IsOrigami], function(Origami)
	return CalcVeechGroupWithHashTables(Origami);
end);

InstallMethod(Cosets, "for a origami", [IsOrigami], function(Origami)
	return RightCosetRepresentatives(VeechGroup(Origami));
end);

InstallMethod(IndexOfMonodromyGroup, [IsOrigami], function(O)
	local sigma_x, sigma_y, d;
	d := DegreeOrigami(O);
	sigma_x := HorizontalPerm(O);
	sigma_y := VerticalPerm(O);
	return IndexNC(SymmetricGroup(d), Group(sigma_x, sigma_y));
end);

#This function calculates the Stratum of an given Origami
#INPUT: An Origami O
#OUTPUT: The Stratum of the Origami as List of Integers.
InstallMethod(Stratum,"for a origami", [IsOrigami], function(O)
	local com, Stratum, CycleStructure, current,i, j;
	com:=HorizontalPerm(O)* VerticalPerm(O) * HorizontalPerm(O)^(-1) * VerticalPerm(O)^(-1);
	CycleStructure:= CycleStructurePerm(com);
	Stratum:=[];
	for i in [1..Length(CycleStructure)] do
		if IsBound(CycleStructure[i]) then
			for j in [1..CycleStructure[i]] do
				Add(Stratum, i);
			od;
		fi;
	od;
	return AsSortedList( Stratum);
end);






InstallGlobalFunction( EquivalentOrigami, function(O1, O2)
	if RepresentativeAction(SymmetricGroup(DegreeOrigami(O1)), [HorizontalPerm(O1), VerticalPerm(O1)],
																			[HorizontalPerm(O2), VerticalPerm(O2)], OnTuples) = fail
		 then return false;
	else
		return true;
	fi;
end
);

InstallGlobalFunction(IsConnectedOrigami, function(origami)
	return IsTransitive(Group(HorizontalPerm(origami), VerticalPerm(origami)), [1..DegreeOrigami(origami)]);
end);


# Calculates the Vecchgroup and the orbit simultan and a matrix list [A_1, .. ,A_n], such that A[i].O = Veechgroup.Orbit[i] . Output is of the form rec(VeechGroup, Orbit,  PathList)
InstallGlobalFunction( CalcVeechGroupAndOrbit , function(O)
	local NewOrigamiList, newOrigamis, sigma, HelpCalc, foundM, W, canonicalOrigamiList, i, j,
	 				counter, HelpO, Orbit, F, S, T, MatrixList, currentBranch, homFreeToMatrix;

	HelpO := OrigamiNormalForm(O);
	F := FreeGroup("S", "T");
	S := GeneratorsOfGroup(F)[1];
	T := GeneratorsOfGroup(F)[2];
	counter := 2;
	sigma:=[[],[]];
	canonicalOrigamiList := [];
	AddHash(canonicalOrigamiList, HelpO, hashForOrigamis);
	SetindexOrigami (HelpO, 1);
	if EquivalentOrigami(ActionOfS( HelpO ), HelpO ) then
		sigma[2][1] := 1;
	fi;
	if EquivalentOrigami(ActionOfT( HelpO ), HelpO ) then
		sigma[1][1] := 1;
	fi;

	Orbit := [HelpO];
	MatrixList := [One(F)];
	HelpCalc := function(GlList)
		NewOrigamiList := [];
		for W in GlList do
			currentBranch :=  [ MatrixList[indexOrigami( W ) ] * T,  MatrixList[indexOrigami( W )]*S ];
			newOrigamis := [OrigamiNormalForm(ActionOfT(W)), OrigamiNormalForm(ActionOfS(W))];
			for j in [1, 2] do
				 #M = newOrigamis[
				i := ContainHash( canonicalOrigamiList, newOrigamis[j], hashForOrigamis );
				if i = 0 then foundM := false; else foundM := true; fi;
				if foundM then
					sigma[j][indexOrigami(W)] := i;
				fi;
				if foundM = false then
					SetindexOrigami(newOrigamis[j], counter);
					AddHash(canonicalOrigamiList, newOrigamis[j], hashForOrigamis);
					Add(Orbit, newOrigamis[j]);
					Add(MatrixList, currentBranch[j]);
					Add(NewOrigamiList, newOrigamis[j]);
					sigma[j][indexOrigami(W)] := counter;
					counter := counter + 1;
				fi;
			od;
		od;
		if Length(NewOrigamiList) > 0 then HelpCalc(NewOrigamiList); fi;
	end;
	HelpCalc( [HelpO] );
	homFreeToMatrix := GroupHomomorphismByImages(F, SpecialLinearGroup(2,Integers), [S, T], GeneratorsOfGroup(SpecialLinearGroup(2,Integers)) );
	return rec( VeechGroup := ModularSubgroup(PermList(sigma[2]), PermList(sigma[1] ) ), Orbit :=  Orbit , PathList := List(MatrixList, x -> ImageElm( homFreeToMatrix, x )) ) ;
end);


InstallGlobalFunction(Elevator, function(length, height, steps)
local sigma_h, sigma_h_step, sigma_v, sigma_v_step, step;
sigma_h:=();
sigma_h_step:=[];
for step in [1 .. steps] do
	sigma_h_step[step]:= CycleFromList([ (step-1)*(length+height)+1 .. (step-1)*(length+height)+length]);
	sigma_h:=sigma_h*sigma_h_step[step];
od;

sigma_v:=();
sigma_v_step:=[];
for step in [1 .. steps-1] do
	sigma_v_step[step]:=CycleFromList([ step*length+(step-1)*height .. step*(length+height)+1]);
	sigma_v:=sigma_v*sigma_v_step[step];
od;
sigma_v_step:=[ steps*length+(steps-1)*height .. steps*(length+height)];
Add(sigma_v_step,1); #connecting the last tile of the last step to the first tile of the first step

sigma_v:=sigma_v*CycleFromList(sigma_v_step );

return OrigamiNormalForm(Origami(sigma_h,sigma_v));
end);

InstallGlobalFunction(Staircase,
function(length, height, steps)
local sigma_h, sigma_h_step, sigma_v, sigma_v_step, step;
sigma_h:=();
sigma_h_step:=[];
for step in [1 .. steps] do
	sigma_h_step[step]:= CycleFromList([ (step-1)*(length+height)+1 .. (step-1)*(length+height)+length]);
	sigma_h:=sigma_h*sigma_h_step[step];
od;

sigma_v:=();
sigma_v_step:=[];
for step in [1 .. steps-1] do
	sigma_v_step[step]:=CycleFromList([ step*length+(step-1)*height .. step*(length+height)+1]);
	sigma_v:=sigma_v*sigma_v_step[step];
od;

sigma_v:=sigma_v*CycleFromList([ steps*length+(steps-1)*height .. steps*(length+height)]);	#Loop one shorter because the last cycle is one shorter.

return OrigamiNormalForm(Origami(sigma_h,sigma_v));
end);


InstallGlobalFunction(XOrigami, function(tiles)
local sigma_h, sigma_v, tile;

sigma_h:=CycleFromList([1..2*tiles]);
sigma_v:=();

for tile in [1 .. tiles] do
	sigma_v:=sigma_v*(2*tile-1, 2*tile);
od;

return OrigamiNormalForm(Origami(sigma_h,sigma_v));
end);

InstallGlobalFunction(QuasiRegularOrigami, function(G,H,r,u)
  local N, tiles, i, j, list_h, sigma_v, sigma_h, list_v;
#test if G is generated by r,u
  if G= Group(r,u) then;
  else Print("Errror: r and u are not the generators of the Group"); return;
  fi;
  if IsSubgroup(G,H) then;
  else Print("Error: H is not a Subgroup of G"); return;
  fi;
#test if H contains normal subgroups of G
N := NormalSubgroups(G);
N:=Filtered(N, i->Size(i)<=Size(H));
  if Filtered(N, i->IsSubgroup(H,i))=[Group(r*Inverse(r))] then;
  else Print("Error: Faulty subgroup. H contains non-trivial normal subgroups of G."); return;
  fi;


tiles:=RightCosets(G,H);
list_v:=[];
list_h:=[];
i:=1;
sigma_h:=();
sigma_v:=();

while i<=Length(tiles) do
j:=1;
list_h:=[];
list_h[1]:=i;
if i in MovedPoints(sigma_h) then;

else #test if the element is already in one of the cycles

  while
    Position(tiles,    tiles[i]*r^j )
    <>
    i

    do;

    list_h[j+1]:=     Position(tiles,    tiles[i]*r^j);
    j:=j+1;
  od;
      #testing if the cycles are disjoint
  if Intersection(MovedPoints(sigma_h), MovedPoints(CycleFromList(list_h)))=[] then
sigma_h:=sigma_h*CycleFromList(list_h);
else; fi;

fi;

  j:=1;
  list_v:=[];
  list_v[1]:=i;


 if i in MovedPoints(sigma_v) then; else
  while
    Position(tiles,    tiles[i] *u^j )
    <>        #continue as long as you reach new elements
  i #=i,
    do;

    list_v[j+1]:=Position(tiles,     tiles[i] * u^j ) ;
    j:=j+1;

    od;

   if  Intersection(MovedPoints(sigma_v), MovedPoints(CycleFromList(list_v)))=[]  then

       sigma_v:=sigma_v *CycleFromList(list_v);
else; fi;
fi;
i:=i+1;
od;
 return OrigamiNormalForm(Origami(sigma_h,sigma_v));
end);


InstallGlobalFunction(DoesNotContainNormalSubgroups, function(G,H)
local N, i;
N:= NormalSubgroups(G);
N:=Filtered(N, i->Size(i)<=Size(H));
if IsSubgroup(G,H)=false then Print("Error: H is not a subgroup of G."); #this case does not happen when the function is called form "QuasiRegularOrigamiFromGroup"
elif H=Group(One(G)) then return true; #H can be the trivial subgroup and be normal
elif IsNormal(G,H) then return false;
elif Filtered(N, i->IsSubgroup(H,i))=[Group(One(G))] then return true;
else return false;
fi;
end);

InstallGlobalFunction(QROFromGroup, function(G)

  local subgroups, j,i,m, origami_list, r, u, F2, f2_epis;
  #Testing if G has 2 Generators
if Length(MinimalGeneratingSet(G))>2 then Print("Error: G has not 2 Generators."); return;
fi;
F2:=FreeGroup(2);
f2_epis:=GQuotients(F2, G);
r:=[]; u:=[];

for i in [1.. Length(f2_epis)] do
 r[i]:=Image(f2_epis[i], F2.1); u[i]:=Image(f2_epis[i],F2.2); od;

#the following List contains all the subgroups of G that do not contain another normal, nontrivial subgroup of G
  subgroups := AllSubgroups(G);
  subgroups:=Filtered(subgroups, i -> DoesNotContainNormalSubgroups(G,i));
  #Calculating the Origamis:
  m:=1;
  origami_list:=[];
for j in [1.. Length(f2_epis)] do

  for i in subgroups do
  origami_list[m]:=QuasiRegularOrigami(G,i, r[j], u[j]);
  origami_list[m+1]:=QuasiRegularOrigami(G, i, u[j], r[j]);
  m:=m+2;
  od;
od;
  origami_list:=DuplicateFreeList(origami_list);
  return origami_list;
end);



InstallGlobalFunction(TwoGeneratedSmallGroups,function(d)
  local permittedSmallGroup;
    permittedSmallGroup:= Filtered(AllSmallGroups(d), i-> Length(MinimalGeneratingSet(i))<=2);
  return permittedSmallGroup;
end);



 InstallGlobalFunction(QROFromOrder,function(d)
    local i, origami_list, newOrigamis, group_list, G;
    #calculating all the permitted permitted groups of order equal to d
   group_list:= TwoGeneratedSmallGroups(d);
    i:=1;
    origami_list:=[];
      for i in [1 .. Length(group_list)]
     do
     newOrigamis:=[];
     G:=group_list[i];
     newOrigamis:=QROFromGroup(G);
     newOrigamis:= DuplicateFreeList(newOrigamis);
     Append(origami_list, newOrigamis);

   od;
   return origami_list;
 end);
