# this function is a helper function to create the correct permutations
# slits is hslits or vslits respectively and cycleFunc is a function
# that gives the right or the bottom neighbour
SlitsToPerm := function(n, d, cycleFunc, slits)
    local lst, q, i, k, numsq, newi, newk;
    
    lst := [];
    numsq := n^2;

    # we interate through all the fields (q ranges from 0 to dn^2-1)
    # and determine the right and lower neighbour
    for q in [0 .. (d*numsq - 1)] do
        i := QuoInt(q, numsq);
        k := (q mod numsq); # 0 based

        # the index of the copy is determined using slits, the actual field is cycled
        newi := (i+slits[k + 1]) mod d;
        newk := cycleFunc(n, k) + 1; # now 1 based
        
        lst[q + 1] := newi * numsq + newk; # also 1 based as needed
    od;
    return PermList(lst);
end;

# define the two functions that give the (cycled) right/bottom neighbour
# important: these are all 0 based, that is, the input must be in [0..n^2-1]
hcycle := {n, k} -> QuoInt(k, n) * n + (((k mod n) + 1) mod n);

vcycle := function(n, k)
    k := k + n;
    if k >= (n^2) then
        k := k - (n^2);
    fi;
    return k;
end;

#! @Arguments n d hslits vslits
#! @Returns a cyclic torus cover origami
#! @Description
#!  A cyclic torus cover consists of d copies of the trivial origami E[n]. Each of the n^2 fields of E[n]
#!  gets assigned a label from 1 to n^2 row-wise from left to right and top down. Let f be a field with the label
#!  k in the i-th copy of the cyclic torus cover. Then f's right neighbour's label is determined by determining the
#!  usual right neighbour in E[n] and its copy is ((i+vslits[k]) mod d). The same goes for the upper neighbour and
#!  hslits.
InstallGlobalFunction(CyclicTorusCover, function(n, d, hslits, vslits)
    return Origami(SlitsToPerm(n, d, hcycle, hslits), SlitsToPerm(n, d, vcycle, vslits));
end);

#! @Arguments n d vslits hslits
#! @Returns the monodromy of the cyclic torus cover described by the given arguments
#! @Description
#!  Since the fundamental group is generated by
#!  - the horizontal path starting in the lower left field
#!  - the vertical path starting in the lower left field
#!  - for each of the n^2 corner points, the cycle around this point
#!  we can uniquely determine the monodromy by just giving its values at these 2+n^2 points. Thus
#!  the function returns an 2+n^2 vector, having the values as described above.
InstallGlobalFunction(CyclicMonodromy, function (n, d, vslits, hslits)
    local lst, i;
    lst := [];
    lst[1] := Sum(vslits{[1..n]}) mod d;   # sicher dass nur die Teilliste von 1 bis n aufsummiert werden soll?
    lst[2] := Sum(List([0..(n-1)], k -> hslits[1 + k*n])) mod d;
    for i in [1..(n^2)] do
        # we need to pay special attention to 0 or 1 based indices
        lst[2 + i] := (hslits[i] + vslits[i] + hslits[hcycle(n, i-1) + 1] + vslits[vcycle(n, i-1) + 1]) mod d;
    od;
    return lst;
end);

#! @Arguments n d vslits hslits
#! @Returns the ramification indices for each of the n^2 fields
InstallGlobalFunction(RamificationIndices, function (n, d, vslits, hslits)
    local R, i, m;
    m := CyclicMonodromy(n, d, vslits, hslits);
    R := [];
    for i in [1..(n^2)] do
        R[i] := Lcm(m[2 + i], d) / m[2 + i];
    od;
    return R;
end);

#! @Arguments n x y
#! @Returns a comb origami, which is a cyclic torus cover of degree 2 specified by a single point P=(x,y)
#! @Description A comb origami is a special cyclic torus cover of degree 2, specified by a single point P
#!  on E[n]. The coordinates are given in the range {0,..,n-1}^2, where the
#!  point (0,0) is located in the lower left corner. P must not be a 2-torsion point, that is, it must not be
#!  (0,0), (n/2, n/2), (n/2,0) or (0,n/2). The coordinates are considered modulo n.
InstallGlobalFunction(CombOrigami, function (n, x, y)
    local coord_to_index, vseams, hseams, vslits, hslits, s, half, connect, rcycle, ucycle, rotate90, 
        A, B, C, D, P, Q, R, S;
    half := n/2;
    x := x mod n;
    y := y mod n;
    if (x=0 and y=0) or (n mod 2 = 0 and ((x = half and y = half) or (x = half and y = 0) or (x = 0 and y = half))) then
        return fail;
    fi;

    rotate90 := k->[(n-k[2]) mod n, k[1] mod n];

    P := [x,y];
    Q := rotate90(P);
    R := rotate90(rotate90(P));
    S := rotate90(rotate90(rotate90(P)));
    A := [y,y];
    B := [n-y, y];
    C := [n-y, n-y];
    D := [y, n-y];

    rcycle := P-> [(P[1] + 1) mod n, P[2]];
    ucycle := P-> [P[1], (P[2] + 1) mod n];
    coord_to_index := A -> A[1] + n*A[2] + 1; # helper to convert 0 based coords to 1 based indices

    # helper that "connects" two points by returning a list of relevant seams
    # is_short_path determines which way to go to connect the two points
    connect := function(A, B, is_short_path)
        local lst;

        A := [A[1] mod n, A[2] mod n]; B := [B[1] mod n, B[2] mod n];
        if (A[1] <> B[1] and A[2] <> B[2]) or A=B then return []; fi;

        lst := [];
        if A[1] = B[1] then
            if (A[2] > B[2] and is_short_path) or (A[2] < B[2] and not is_short_path) then
                return connect(B, A, is_short_path);
            fi;
            # vertical seam
            Add(lst, coord_to_index([(A[1] - 1) mod n, A[2]]));
            while ucycle(A) <> B do
                A := ucycle(A);
                Add(lst, coord_to_index([(A[1] - 1) mod n, A[2]]));
            od;
        else
            if (A[1] > B[1] and is_short_path) or (A[1] < B[1] and not is_short_path) then
                return connect(B, A, is_short_path);
            fi;
            # horizontal seam
            Add(lst, coord_to_index([A[1], (A[2] - 1) mod n]));
            while rcycle(A) <> B do
                A := rcycle(A);
                Add(lst, coord_to_index([A[1], (A[2] - 1) mod n]));
            od;
        fi;

        
        return lst;
    end;

    # the different cass
    if y=0 then # on a line through 0
        hseams := connect(P, R, true);
        vseams := connect(Q, S, true);
    elif x=0 then
        vseams := connect(P, R, true);
        hseams := connect(Q, S, true);
    elif x=-y  or x=y then # diagonal
        hseams := Union([connect(P, Q, true), connect(P, Q, false)]);
        vseams := Union([connect(R, Q, false), connect(P, S, true)]);
    elif (x=half or y=half) and n mod 2 = 0 then # on a line through M
        # unclear where e3 goes, we assume B to A over the edge
        hseams := Union([connect(P, B, true), connect(B, A, false), connect(R, C, true)]);
        vseams := Union([connect(B, Q, true), connect(C, B, false), connect(A, S, true)]);
    else # inside a triangle
        hseams := Union([connect(P, B, true), connect(B, A, false), connect(R, C, true)]);
        vseams := Union([connect(Q, C, true), connect(S, A, false)]);
    fi;
    
    s := function (i, points) if i in points then return 1; else return 0; fi; end;
    vslits := List([1..n^2], i -> s(i, vseams));
    hslits := List([1..n^2], i -> s(i, hseams));

    return CyclicTorusCover(n, 2, vslits, hslits);
end);