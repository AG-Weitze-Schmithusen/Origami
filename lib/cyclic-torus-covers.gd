#! @Chapter Cyclic Torus Covers
#! @ChapterLabel cyclic-torus-covers

#! @Section Cyclic Torus Covers functions

#! @Arguments n d hslits vslits
#! @Returns a cyclic torus cover origami
#! @Description
#!  A cyclic torus cover consists of d copies of the trivial origami E[n]. Each of the n^2 fields of E[n]
#!  gets assigned a label from 1 to n^2 row-wise from left to right and bottom up. Let f be a field with the label
#!  k in the i-th copy of the cyclic torus cover. Then f's right neighbour's label is determined by determining the
#!  usual right neighbour in E[n] and its copy is ((i+vslits[k]) mod d). The same goes for the upper neighbour and
#!  hslits.
DeclareGlobalFunction("CyclicTorusCover");

#! @Arguments n d vslits hslits
#! @Returns the monodromy of the cyclic torus cover described by the given arguments
#! @Description
#!  Since the fundamental group is generated by
#!  - the horizontal path starting in the lower left field
#!  - the vertical path starting in the lower left field
#!  - for each of the n^2 corner points, the cycle around this point
#!  we can uniquely determine the monodromy by just giving its values at these 2+n^2 points. Thus
#!  the function returns an 2+n^2 vector, having the values as described above.
DeclareGlobalFunction("CyclicMonodromy");

#! @Arguments n d vslits hslits
#! @Returns the ramification indices for each of the n^2 fields
DeclareGlobalFunction("RamificationIndices");

#! @Section Comb Origami functions

#! @Arguments n x y
#! @Returns a comb origami, which is a cyclic torus cover of degree 2 specified by a single point P=(x,y)
#! @Description A comb origami is a special cyclic torus cover of degree 2, specified by a single point P
#!  on E[n]. The coordinates are given in the range {0,..,n-1}^2, where the
#!  point (0,0) is located in the lower left corner. P must not be a 2-torsion point, that is, it must not be
#!  (0,0), (n/2, n/2), (n/2,0) or (0,n/2). The coordinates are considered modulo n.
DeclareGlobalFunction("CombOrigami");

#DeclareCategory("IsCyclCov", IsObject);
#BindGlobal("CyclCovFamily",NewFamily("CyclCov"));

#DeclareAttribute("TorsionDegree", IsCyclCov);
#DeclareAttribute("Degree", IsCyclCov);
#DeclareAttribute("HomologyDimension", IsCyclCov);
#DeclareAttribute("BCoefficients", IsCyclCov);
#DeclareAttribute("SCoefficients", IsCyclCov);
#DeclareAttribute("Origami", IsCyclCov);

#DeclareOperation("CyclCoverByB", [IsPosInt, IsPosInt, IsList]);
DeclareGlobalFunction("CyclicCoverByS", [IsPosInt, IsPosInt, IsList]);

DeclareGlobalFunction("TranslationGroup", [IsPosInt]);
# DeclareGlobalFunction("BaseChangeSToB", [IsPosInt]);