<Chapter Label="Functionality">
<Heading>The functionality of this package</Heading>

<Section Label="BasicOrigamiConstr">
<Heading>Basic contruction of origamis</Heading>

<ManSection>

  <Oper Name="Origami" Arg="sigma_x, sigma_y"/>
  <Returns>An origami.</Returns>
  <Description>
    This function constructs an <C>Origami</C> object from two given permutations <M>\sigma_x</M> and <M>\sigma_y</M>. A test is performed to check whether the surface described by the given permutations is connected, i.e. whether the group generated by the two permutations acts transitively.
    <Example>
    <![CDATA[
    gap> O := Origami((1,2,3,4,5),(5,6));
    Origami((1,2,3,4,5), (5,6), 6)
    ]]>
    </Example>
  </Description>

  <Oper Name="OrigamiNC" Arg="sigma_x, sigma_y"/>
  <Returns>An origami.</Returns>
  <Description>
    This function constructs an <C>Origami</C> object from two given permutations <M>\sigma_x</M> and <M>\sigma_y</M> without checking whether or not the described surface is connected.
    <Example>
    <![CDATA[
    gap> O := OrigamiNC((1,2,3,4,5),(5,6));
    Origami((1,2,3,4,5), (5,6), 6)
    ]]>
    </Example>
  </Description>

  <Attr Name="HorizontalPerm" Arg="O"/>
  <Returns>A permutation.</Returns>
  <Description>
    Returns the permutation <M>\sigma_x</M> describing the horizontal glueing of the unit squares.
    <Example>
      <![CDATA[
      gap> O := Origami((1,2,3,4,5),(5,6));
      Origami((1,2,3,4,5), (5,6), 6)
      gap> HorizontalPerm(O);
      (1,2,3,4,5)
      ]]>
    </Example>
  </Description>

  <Attr Name="VerticalPerm" Arg="O"/>
  <Returns>A permutation.</Returns>
  <Description>
    Returns the permutation <M>\sigma_y</M> describing the vertical glueing of the unit squares.
    <Example>
      <![CDATA[
      gap> O := Origami((1,2,3,4,5),(5,6));
      Origami((1,2,3,4,5), (5,6), 6)
      gap> VerticalPerm(O);
      (5,6)
      ]]>
    </Example>
  </Description>

  <Attr Name="DegreeOrigami" Arg="O"/>
  <Returns>A positive integer.</Returns>
  <Description>
    Returns the degree of the origami <A>O</A>, i.e. the number of unit squares which are glued together. In terms of permutations, the degree corresponds to the largest moved point of <M>\sigma_x</M> and <M>\sigma_y</M>.
    <Example>
      <![CDATA[
      gap> O := Origami((1,2,3,4,5),(5,6));
      Origami((1,2,3,4,5), (5,6), 6)
      gap> DegreeOrigami(O);
      6
      ]]>
    </Example>
  </Description>

</ManSection>

</Section>

<Section Label="SL2Action">
<Heading>The <M>SL_2(\mathbb Z)</M>-action</Heading>
The group <M>SL_2(\mathbb Z)</M> acts on the set of all origamis via the following formulas:
<Display>
  S.O(\sigma_x, \sigma_y) = O(\sigma_y^{-1}, \sigma_x), \qquad T.O(\sigma_x, \sigma_y) = O(\sigma_x, \sigma_y \sigma_x^{-1})
</Display>
where <M>S</M> and <M>T</M> denote the standard generators
<Alt Only="LaTeX">
  <![CDATA[
  \[
    S =
    \left(
      \begin{array}{rr}
        0 & -1 \\
        1 & 0
      \end{array}
    \right)
    ,\quad
    T =
    \left(
      \begin{array}{rr}
        1 & 1 \\
        0 & 1
      \end{array}
    \right)
  \]
]]>
</Alt>
<Alt Only="Text,HTML">
  <Verb><![CDATA[
                     [ 0 -1 ]            [ 1  1 ]
                 S = [ 1  0 ],       T = [ 0  1 ]
  ]]></Verb>
</Alt>

of <M>SL_2(\mathbb Z)</M>. The succeeding methods implement this action in GAP.

<ManSection>

  <Oper Name="ActionOfS" Arg="O"/>
  <Returns>An origami.</Returns>
  <Description>
    For a given origami <A>O</A> this methods computes the origami <M>S.O</M> as described above.
    <Example>
      <![CDATA[
      gap> O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap> ActionOfS(O);
      Origami((1,6,2,8,3,5,4), (1,6,4,7,5,3)(2,8), 8)
      ]]>
    </Example>
  </Description>

  <Oper Name="ActionOfT" Arg="O"/>
  <Returns>An origami.</Returns>
  <Description>
    For a given origami <A>O</A> this methods computes the origami <M>T.O</M> as described above.
    <Example>
      <![CDATA[
      gap> O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap> ActionOfT(O);
      Origami((1,6,4,7,5,3)(2,8), (1,6,3,2)(4,7), 8)
      ]]>
    </Example>
  </Description>

  <Oper Name="ActionOfSInv" Arg="O"/>
  <Returns>An origami.</Returns>
  <Description>
    For a given origami <A>O</A> this methods computes the origami <M>S^{-1}.O</M>.
    <Example>
      <![CDATA[
      gap> O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap> ActionOfSInv(O);
      Origami((1,4,5,3,8,2,6), (1,3,5,7,4,6)(2,8), 8)
      ]]>
    </Example>
  </Description>

  <Oper Name="ActionOfTInv" Arg="O"/>
  <Returns>An origami.</Returns>
  <Description>
    For a given origami <A>O</A> this methods computes the origami <M>T^{-1}.O</M>.
    <Example>
      <![CDATA[
      gap> O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap> ActionOfTInv(O);
      Origami((1,6,4,7,5,3)(2,8), (1,7,5)(2,4,3), 8)
      ]]>
    </Example>
  </Description>

  <Oper Name="ActionOfSL2" Arg="w, O"/>
  <Returns>An origami.</Returns>
  <Description>
    For a given origami <A>O</A> and a word <A>w</A> in <M>S</M> and <M>T</M> (given as a string), this methods computes the origami <M>w^{-1}.O</M>.
    <Example>
      <![CDATA[
      gap> O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap> ActionOfSL2("S*T", O);
      Origami((1,6,2,8,3,5,4), (3,4,7)(5,8,6), 8)
      ]]>
    </Example>
  </Description>

</ManSection>

</Section>


<Section Label="OriNormalForm">
<Heading>Equivalence of origamis and normal forms</Heading>
We consider two origamis to be equivalent (or isomorphic), if they are the same up to relabeling the squares. In terms of pairs of permutations, this corresponds to simultaneous conjugation. Equivalence can be checked by computing a certain normal form for origamis.

<ManSection>

  <Oper Name="OrigamiNormalForm" Arg="O"/>
  <Returns>An origami.</Returns>
  <Description>
    Computes a normal form of a given origami. This normal form has the property that two origamis are equivalent if and only if their normal form are equal.
    Note that this method does not copy any previously computed attributes from the old origami to the new one.
    <Example>
      <![CDATA[
      gap> O := Origami((1,3,2,4),(2,3));
      Origami((1,3,2,4), (2,3), 4)
      gap> OrigamiNormalForm(O);
      Origami((1,2,3,4), (3,4), 4)
      ]]>
    </Example>
  </Description>

  <Oper Name="CopyOrigamiInNormalForm" Arg="O"/>
  <Returns>An origami.</Returns>
  <Description>
    This method does the same as <C>OrigamiNormalForm</C> but <E>does copy</E> previously computed attributes.
  </Description>

  <Oper Name="OrigamisEquivalent" Arg="O1, O2"/>
  <Returns>Two origamis.</Returns>
  <Description>
    Checks whether two given origamis are equivalent by comparing their normal forms.
    <Example>
      <![CDATA[
      gap> P := Origami((1,2,3,4), (3,4), 4);
      Origami((1,2,3,4), (3,4), 4)
      gap> O := Origami((1,3,2,4),(2,3));
      Origami((1,3,2,4), (2,3), 4)
      gap> OrigamisEquivalent(O, P);
      true
      ]]>
    </Example>
  </Description>

</ManSection>

</Section>



<Section Label="OrigamiAttr">
<Heading>Computing attributes of origamis</Heading>

<ManSection>

  <Attr Name="Stratum" Arg="O"/>
  <Returns>A (possibly empty) list of positive integers.</Returns>
  <Description>
    This function calculates the stratum of an origami, i.e. the list of the nonzero degrees
    of the singularities. For a singularity of cone angle <M>2 k \pi</M> the degree of the singularity is <M>k-1</M>.
    <Example>
      <![CDATA[
      gap> Stratum(Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6)));
      [ 1, 5 ]
      ]]>
    </Example>
  </Description>

  <Attr Name="Genus" Arg="O"/>
  <Returns>A non-negative integer.</Returns>
  <Description>
    Calculates the genus of an origami.
    <Example>
    <![CDATA[
    gap> Genus(Origami((1,2,3,4), (1,2)(3,4)));
    2
    ]]>
    </Example>
  </Description>

  <Attr Name="IndexOfMonodromyGroup" Arg="O"/>
  <Returns>A positive integer.</Returns>
  <Description>
    Calculates the index of the monodromy group of an origami, i.e. the index of the subgroup generated by <M>\sigma_x</M> and <M>\sigma_y</M> in <M>S_d</M> where <M>d</M> is the degree of the origami.
    <Example>
    <![CDATA[
    gap> IndexOfMonodromyGroup(Origami((1,3,6)(4,5),(2,4,3,5)(7,1)));
    1
    ]]>
    </Example>
  </Description>

  <Attr Name="VeechGroup" Arg="O"/>
  <Returns>A subgroup of <M>SL_2(\mathbb Z)</M>.</Returns>
  <Description>
    The Veech group of an origami is a finite-index subgroup of <M>SL_2(\mathbb{Z})</M>. In GAP it is is represented as a <C>ModularSubgroup</C> from the <Package>ModularGroup</Package> package. It is determined by two permutations <M>\sigma_S</M> and <M>\sigma_T</M> describing how the generators <M>S</M> and <M>T</M> of <M>SL_2(\mathbb{Z})</M> act on the cosets.

    See <Cite Key="veech_alg_schmithuesen"/> for a detailed description of the algorithm used to compute the Veech group.
    <Example>
    <![CDATA[
    gap> O := Origami((1,2,5)(3,4,6), (1,2)(5,6));
    Origami((1,2,5)(3,4,6), (1,2)(5,6), 6)
    gap> G := VeechGroup(O);
    <modular subgroup of index 10>
    gap> Display(G);
    ModularSubgroup(
    S : ( 1, 2)( 3, 6)( 4, 7)( 5, 8)( 9,10)
    T : ( 1, 3)( 2, 4, 5)( 6, 8,10, 9, 7)
    R : ( 1, 8, 7)( 2, 6)( 3, 4,10, 9, 5)
    J : ( 1, 5, 6)( 2, 3, 7)( 4, 9, 8) )
    ]]>
    </Example>
  </Description>

  <Oper Name="VeechGroupAndOrbit" Arg="O"/>
  <Returns>A record.</Returns>
  <Description>
    Computes both the Veech group and the orbit under the <M>SL_2(\mathbb Z)</M> action of a given origami <A>O</A>. Also returns the matrices with map the origami <A>O</A> to the corresponding orbit elements.

    The returned record has the following format:
    <List>
      <Item><E>VeechGroup</E> : the Veech group as a <C>ModularSubgroup</C></Item>
      <Item><E>orbit</E> : the <M>SL_2(\mathbb Z)</M>-orbit of <A>O</A> as a list of <C>Origami</C>s</Item>
      <Item><E>matrices</E> : a list of matrices mapping <A>O</A> to the corresponding orbit elements</Item>
    </List>
  </Description>

  <Attr Name="DeckGroup" Arg="O"/>
  <Returns>A group.</Returns>
  <Description>
    Computes the group of deck transformations of the origami <A>O</A> as a covering of the once punctured torus. Note that the deck transformations can be seen as permutations of the squares of the origami.
    <Example>
    <![CDATA[
    gap> O := Origami((1,2,3,4,5), (), 5);
    Origami((1,2,3,4,5), (), 5)
    gap> DeckGroup(O);
    Group([ (), (1,2,3,4,5), (1,3,5,2,4), (1,4,2,5,3), (1,5,4,3,2) ])
    ]]>
    </Example>
  </Description>

  <Oper Name="IsElementOfDeckGroup" Arg="p, O"/>
  <Returns>A boolean.</Returns>
  <Description>
    Checks whether or not the permutation <A>p</A> defines a deck transformation of the origami <A>O</A>.
  </Description>

  <Attr Name="IsNormalOrigami" Arg="O"/>
  <Returns>A boolean.</Returns>
  <Description>
    Checks whether or not a given origami is normal. An origami is called normal if its deck group acts transitively on the fibers of the covering.
    <Example>
    <![CDATA[
    gap> O := Origami((1,2,3,4,5), (), 5);
    Origami((1,2,3,4,5), (), 5)
    gap> IsNormalOrigami(O);
    true
    ]]>
    </Example>
  </Description>

  <Func Name="SumOfLyapunovExponents" Arg="O"/>
  <Returns> A positiv Integer. </Returns>
  <Description>
    This function calculates the sum of the positive Lyapunov exponents of the Origami <A>O</A>.
    <Example>
      <![CDATA[
      gap> O:=Origami((1,2,3,4,5,6,7,8,9),(1,3)(2,4,8)(5,7));
      Origami((1,2,3,4,5,6,7,8,9), (1,3)(2,4,8)(5,7), 9)
      gap> SumOfLyapunovExponents(O);
      32/15
      ]]>
    </Example>
  </Description>

</ManSection>

</Section>


<Section Label="NormalOrigamis">
<Heading>Normal Origamis</Heading>
Normal origamis can equivalently be described by a finite group <M>G</M> and a pair <M>x, y</M> of generators of <M>G</M>. The elements of <M>G</M> correspond to squares and the horizontal (resp. vertical) glueing is determined by left multiplication with <M>x</M> (resp. <M>y</M>), i.e. if <M>g,h \in G</M> then <M>g</M> is glued to <M>h</M> in the <M>x</M>-direction if <M>xg = h</M> and analogously for the <M>y</M>-direction.
The group <M>G</M> is then evidently the deck group of the described origami. Furthermore, every normal origami is of this form where <M>G</M> is its deck group.
Two normal origamis <M>(x, y, G)</M>, <M>(x',y',G)</M> given in such a form are equivalent if and only if there is an automorphism <M>\varphi \in \textrm{Aut}(G)</M> of <M>G</M> such that <M>\varphi(x) = x'</M> and <M>\varphi(y) = y'</M>.
We introduce a new GAP-category called <C>IsNormalStoredOrigami</C> which is a subcategory of the <C>Origami</C>-category for representing normal origamis which are given in terms of the above data.
Since every <C>NormalStoredOrigami</C> is also an <C>Origami</C>, every method implemented for <C>Origami</C>s is also available for <C>NormalStoredOrigami</C>s.

<ManSection>

  <Oper Name="NormalStoredOrigami" Arg="x, y, G"/>
  <Returns>A normal origami.</Returns>
  <Description>
    For a given finite group <A>G</A> and two generators <A>x, y</A> this method constructs a new normal origami in the way described above. It is given as a <C>NormalStoredOrigami</C> object.
    This constructor checks whether or not <A>G</A> is actually generated by <A>x</A> and <A>y</A>.
    <Example>
    <![CDATA[
    gap> G := AlternatingGroup(8);
    Alt( [ 1 .. 8 ] )
    gap> gen := MinimalGeneratingSet(G);
    [ (1,2,3,4,5,6,7), (6,7,8) ]
    gap> x := gen[1];; y := gen[2];;
    gap> O := NormalStoredOrigami(x, y, G);
    Normal Origami( A_8.1^-1*A_8.2*A_8.1 , A_8.1^-1*A_8.2, Group( [ A_8.1, A_8.2 ]) )
    ]]>
    </Example>
  </Description>

  <Oper Name="NormalStoredOrigamiNC" Arg="x, y, G"/>
  <Returns>A normal origami.</Returns>
  <Description>
    Does the same as the <C>NormalStoredOrigami</C> constructor above but does not check whether or not <A>G</A> is generated by <A>x</A> and <A>y</A>.
  </Description>

  <Attr Name="HorizontalElement" Arg="O"/>
  <Returns>A group element.</Returns>
  <Description>
    For a <C>NormalStoredOrigami</C>, this method returns the <M>x</M>-element which describes the glueing in the horizontal direction.
  </Description>

  <Attr Name="VerticalElement" Arg="O"/>
  <Returns>A group element.</Returns>
  <Description>
    For a <C>NormalStoredOrigami</C>, this method returns the <M>y</M>-element which describes the glueing in the vertical direction.
  </Description>

  <Oper Name="AsPermutationRepresentation" Arg="O"/>
  <Returns>An origami.</Returns>
  <Description>
    Converts a <C>NormalStoredOrigami</C> into an <C>Origami</C>, i.e. computes the <M>x</M>- and <M>y</M>-permutations describing the glueing of the squares.
    <Example>
    <![CDATA[
    gap> G := AlternatingGroup(4);
    Alt( [ 1 .. 4 ] )
    gap> gen := MinimalGeneratingSet(G);
    [ (2,4,3), (1,3)(2,4) ]
    gap> x := gen[1];; y := gen[2];;
    gap> O := NormalStoredOrigami(x, y, G);
    Normal Origami( f1 , f2, Group( [ f1, f2, f3 ] ) )
    gap> AsPermutationRepresentation(O);
    Origami((1,2,5)(3,6,9)(4,7,10)(8,11,12), (1,3)(2,7)(4,8)(5,12)(6,11)(9,10), 12)
    ]]>
    </Example>
  </Description>

  <Oper Name="AsPermutationRepresentation" Arg="O"/>
  <Returns>An origami.</Returns>
  <Description>
    Converts a normal <C>Origami</C> into a <C>NormalStoredOrigami</C>.
  </Description>

  <Oper Name="AllNormalOrigamisFromGroup" Arg="G"/>
  <Returns>A list of normal origamis.</Returns>
  <Description>
    For a given group <A>G</A>, this method computes all normal origamis (up to equivalence) which can be build from <A>G</A>.
    <Example>
    <![CDATA[
    gap> G := AlternatingGroup(4);
    Alt( [ 1 .. 4 ] )
    gap> AllNormalOrigamisFromGroup(G);
    [ Normal Origami( f3 , f1*f3, Group( [ f1, f2, f3 ] ) ),
    Normal Origami( f1 , f3, Group( [ f1, f2, f3 ] ) ),
    Normal Origami( f1 , f1*f3, Group( [ f1, f2, f3 ] ) ),
    Normal Origami( f1 , f1^2*f3, Group( [ f1, f2, f3 ] ) ) ]
    ]]>
    </Example>
  </Description>

  <Oper Name="AllNormalOrigamisByDegree" Arg="d"/>
  <Returns>A list of normal origamis.</Returns>
  <Description>
    Computes all normal origamis (up to equivalence) with degree <A>d</A>.
    <Example>
    <![CDATA[
    gap> AllNormalOrigamisByDegree(5);
    [ Normal Origami( <identity> of ... , f1, Group( [ f1 ] ) ),
    Normal Origami( f1 , <identity> of ..., Group( [ f1 ] ) ),
    Normal Origami( f1 , f1, Group( [ f1 ] ) ),
    Normal Origami( f1 , f1^2, Group( [ f1 ] ) ),
    Normal Origami( f1 , f1^3, Group( [ f1 ] ) ),
    Normal Origami( f1 , f1^4, Group( [ f1 ] ) ) ]
    ]]>
    </Example>
  </Description>

</ManSection>

</Section>


<Section Label="OrigamiExamples">
<Heading>Constructing examples of origamis</Heading>
In this section we describe some methods for constructing explicit examples and families of origamis.


<ManSection>

  <Oper Name="AllOrigamisByDegree" Arg="d"/>
  <Returns>A list of origamis.</Returns>
  <Description>
    Returns a list of all origamis of degree <A>d</A> up to equivalence.
  </Description>

  <Oper Name="AllOrigamisInStratum" Arg="d, stratum"/>
  <Returns>A list of origamis.</Returns>
  <Description>
    Returns a list of all origamis of degree <A>d</A> in the given stratum.
    <Example>
    <![CDATA[
    gap> OrigamiListInStratum(4, [1,1]);
    [ Origami((1,2), (1,3)(2,4), 4), Origami((1,2), (1,3,2,4), 4),
      Origami((1,2)(3,4), (2,3), 4), Origami((1,2)(3,4), (2,3,4), 4),
      Origami((1,2)(3,4), (1,2,3,4), 4), Origami((1,2,3), (2,3,4), 4),
      Origami((1,2,3), (2,4,3), 4), Origami((1,2,3), (1,2)(3,4), 4),
      Origami((1,2,3,4), (2,4), 4), Origami((1,2,3,4), (1,2)(3,4), 4) ]
    ]]>
    </Example>
  </Description>

  <Oper Name="RandomOrigami" Arg="d"/>
  <Returns>An origami.</Returns>
  <Description>
    Returns random origami of degree <A>d</A>.
    <Example>
    <![CDATA[
    gap> RandomOrigami(6);
    Origami((1,3,5,6,4), (2,3,4,5,6), 6)
    ]]>
    </Example>
  </Description>

  <Oper Name="XOrigami" Arg="d"/>
  <Returns>An origami.</Returns>
  <Description>
    This function calculates an origami of degree <M>2d</M>. The permutations are given by
    <M> /sigma_h = (1,...,2k) </M> and <M> /sigma_v=(1,2)(3,4)...(2k, 2k-1)</M>.
    <Example>
      gap> XOrigami(2);
      Origami((1,2,3,4), (1,2)(3,4), 4)
    </Example>
  </Description>

  <Oper Name="ElevatorOrigami" Arg="l, h, s"/>
  <Returns>An origami.</Returns>
  <Description>
    The function calculates an Origami similar to the staircase origami, but the first tile of the first
    step and the last tile of the last tile are connected. The permutations are given by
    <M> /sigma_h= (1,..., a)/circ(a + b + 1,...,2a + b)/circ(2a + 2b + 1,...,3a + 2b)/circ...
 /circ((d - 1)(a + b) + 1,...,da + (d - 1)b)</M> and
    <M> /sigma_v = (a, a + 1,...,a + b + 1)/circ(2a + b, 2a + b + 1,...,2a + 2b + 1)/circ...
/circ (da + (d - 1)b, da + (d - 1)b + 1,..., d(a + b),1)</M>
    <Example>
      gap>  Elevator(2,0,3);
      Origami((1,2)(3,5)(4,6), (1,3)(2,4)(5,6), 6)
    </Example>
  </Description>

  <Oper Name="StaircaseOrigami" Arg="l, h, s"/>
  <Returns>An origami.</Returns>
  <Description>
    This function calculates a "staircase" origami of <Arg>steps</Arg> steps.
    Each step has length <Arg>length</Arg> and height <Arg>height</Arg>. The permutations are given by
    <M> /sigma_h= (1,..., a)/circ(a + b + 1,...,2a + b)/circ(2a + 2b + 1,...,3a + 2b)/circ...
 /circ((d - 1)(a + b) + 1,...,da + (d - 1)b)</M> and
    <M> /sigma_v = (a, a + 1,...,a + b + 1)/circ(2a + b, 2a + b + 1,...,2a + 2b + 1)/circ...
/circ (da + (d - 1)b, da + (d - 1)b + 1,..., d(a + b))</M>
    <Example>
      gap> Staircase(2,0,3);
      Origami((1,2)(3,4)(5,6), (2,3)(4,5), 6)
    </Example>
  </Description>

  <Oper Name="QuasiRegularOrigami" Arg="G, H, r, u"/>
  <Returns>An origami.</Returns>
  <Description>
    The function calculates an origami by a given group <Arg>G</Arg> and a subgroup of <Arg>G</Arg> <Arg>H</Arg>.
    <Arg>H</Arg> must not contain any normal subgroups of G and <Arg>r</Arg> and <Arg>u</Arg> are the generators of G.
    We identify the tiles of the origami with the right cosets of H in G.
    The right neighbour of the tile <M>Hg</M> is the tile <M>Hgr</M> and the upper neighbour of
    <M>Hg</M> is <M>Hgu</M>.
    <Example>
      G:=SymmetricGroup(3);
      Sym( [ 1 .. 3 ] )
      gap> H:=Group(());
      Group(())
      gap>QuasiRegularOrigami(G,H,(1,2),(2,3));
      Origami((1,2)(3,5)(4,6), (1,3)(2,4)(5,6), 6)
    </Example>
  </Description>

  <Oper Name="QROFromGroup" Arg="G"/>
  <Returns>A list of origamis.</Returns>
  <Description>
    Returns a list of all quasi-regular origamis which can be build from the group <A>G</A>.
  </Description>

  <Oper Name="QROFromOrder" Arg="d"/>
  <Returns>A list of origamis.</Returns>
  <Description>
    Returns a list of all quasi-regular origamis of order <A>d</A>.
  </Description>

</ManSection>

</Section>

</Chapter>
