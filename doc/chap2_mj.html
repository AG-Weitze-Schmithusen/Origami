<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (Origami) - Chapter 2: The functionality of this package</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2.html">[MathJax off]</a></p>
<p><a id="X86FF9741842D9DD2" name="X86FF9741842D9DD2"></a></p>
<div class="ChapSects"><a href="chap2_mj.html#X86FF9741842D9DD2">2 <span class="Heading">The functionality of this package</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X8342F181851BAF16">2.1 <span class="Heading">Basic construction of origamis</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X80F0ED3B78404E71">2.1-1 Origami</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7D153FC985E5ED5E">2.2 <span class="Heading">The <span class="SimpleMath">\(SL_2(\mathbb Z)\)</span>-action</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7911B2158207B4C6">2.2-1 ActionOfS</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X80E9A8A7876A8E81">2.3 <span class="Heading">Equivalence of origamis and normal forms</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X802D1FAC7A4431ED">2.3-1 OrigamiNormalForm</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7A430F877A4960EF">2.4 <span class="Heading">Computing attributes of origamis</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D4E90288408DB38">2.4-1 Stratum</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X838AD31B7BF71CDF">2.5 <span class="Heading">Normal Origamis</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X804339A77C4C3621">2.5-1 NormalStoredOrigami</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7AEE4C27789665DA">2.6 <span class="Heading">Constructing examples of origamis</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X818AFD7783755B39">2.6-1 AllOrigamisByDegree</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">The functionality of this package</span></h3>

<p><a id="X8342F181851BAF16" name="X8342F181851BAF16"></a></p>

<h4>2.1 <span class="Heading">Basic construction of origamis</span></h4>

<p><a id="X80F0ED3B78404E71" name="X80F0ED3B78404E71"></a></p>

<h5>2.1-1 Origami</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Origami</code>( <var class="Arg">sigma_x</var>, <var class="Arg">sigma_y</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>This function constructs an <code class="code">Origami</code> object from two given permutations <span class="SimpleMath">\(\sigma_x\)</span> and <span class="SimpleMath">\(\sigma_y\)</span>. A test is performed to check whether the surface described by the given permutations is connected, i.e. whether the group generated by the two permutations acts transitively.</p>


<div class="example"><pre>
    
    gap&gt; O := Origami((1,2,3,4,5),(5,6));
    Origami((1,2,3,4,5), (5,6), 6)
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrigamiNC</code>( <var class="Arg">sigma_x</var>, <var class="Arg">sigma_y</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>This function constructs an <code class="code">Origami</code> object from two given permutations <span class="SimpleMath">\(\sigma_x\)</span> and <span class="SimpleMath">\(\sigma_y\)</span> without checking whether or not the described surface is connected.</p>


<div class="example"><pre>
    
    gap&gt; O := OrigamiNC((1,2,3,4,5),(5,6));
    Origami((1,2,3,4,5), (5,6), 6)
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HorizontalPerm</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A permutation.</p>

<p>Returns the permutation <span class="SimpleMath">\(\sigma_x\)</span> describing the horizontal gluing of the unit squares.</p>


<div class="example"><pre>
      
      gap&gt; O := Origami((1,2,3,4,5),(5,6));
      Origami((1,2,3,4,5), (5,6), 6)
      gap&gt; HorizontalPerm(O);
      (1,2,3,4,5)
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VerticalPerm</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A permutation.</p>

<p>Returns the permutation <span class="SimpleMath">\(\sigma_y\)</span> describing the vertical gluing of the unit squares.</p>


<div class="example"><pre>
      
      gap&gt; O := Origami((1,2,3,4,5),(5,6));
      Origami((1,2,3,4,5), (5,6), 6)
      gap&gt; VerticalPerm(O);
      (5,6)
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DegreeOrigami</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A positive integer.</p>

<p>Returns the degree of the origami <var class="Arg">O</var>, i.e. the number of unit squares which are glued together. In terms of permutations, the degree corresponds to the largest moved point of <span class="SimpleMath">\(\sigma_x\)</span> and <span class="SimpleMath">\(\sigma_y\)</span>.</p>


<div class="example"><pre>
      
      gap&gt; O := Origami((1,2,3,4,5),(5,6));
      Origami((1,2,3,4,5), (5,6), 6)
      gap&gt; DegreeOrigami(O);
      6
      
    </pre></div>

<p><a id="X7D153FC985E5ED5E" name="X7D153FC985E5ED5E"></a></p>

<h4>2.2 <span class="Heading">The <span class="SimpleMath">\(SL_2(\mathbb Z)\)</span>-action</span></h4>

<p>The group <span class="SimpleMath">\(SL_2(\mathbb Z)\)</span> acts on the set of all origamis via the following formulas:</p>

<p class="center">\[
  S.O(\sigma_x, \sigma_y) = O(\sigma_y^{-1}, \sigma_x), \qquad T.O(\sigma_x, \sigma_y) = O(\sigma_x, \sigma_y \sigma_x^{-1})
\]</p>

<p>where <span class="SimpleMath">\(S\)</span> and <span class="SimpleMath">\(T\)</span> denote the standard generators</p>


<pre class="normal">

                     [ 0 -1 ]            [ 1  1 ]
                 S = [ 1  0 ],       T = [ 0  1 ]
  
</pre>

<p>of <span class="SimpleMath">\(SL_2(\mathbb Z)\)</span>. The succeeding methods implement this action in GAP.</p>

<p><a id="X7911B2158207B4C6" name="X7911B2158207B4C6"></a></p>

<h5>2.2-1 ActionOfS</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ActionOfS</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>For a given origami <var class="Arg">O</var> this methods computes the origami <span class="SimpleMath">\(S.O\)</span> as described above.</p>


<div class="example"><pre>
      
      gap&gt; O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap&gt; ActionOfS(O);
      Origami((1,6,2,8,3,5,4), (1,6,4,7,5,3)(2,8), 8)
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ActionOfT</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>For a given origami <var class="Arg">O</var> this methods computes the origami <span class="SimpleMath">\(T.O\)</span> as described above.</p>


<div class="example"><pre>
      
      gap&gt; O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap&gt; ActionOfT(O);
      Origami((1,6,4,7,5,3)(2,8), (1,6,3,2)(4,7), 8)
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ActionOfSInv</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>For a given origami <var class="Arg">O</var> this methods computes the origami <span class="SimpleMath">\(S^{-1}.O\)</span>.</p>


<div class="example"><pre>
      
      gap&gt; O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap&gt; ActionOfSInv(O);
      Origami((1,4,5,3,8,2,6), (1,3,5,7,4,6)(2,8), 8)
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ActionOfTInv</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>For a given origami <var class="Arg">O</var> this methods computes the origami <span class="SimpleMath">\(T^{-1}.O\)</span>.</p>


<div class="example"><pre>
      
      gap&gt; O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap&gt; ActionOfTInv(O);
      Origami((1,6,4,7,5,3)(2,8), (1,7,5)(2,4,3), 8)
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ActionOfSL2</code>( <var class="Arg">w</var>, <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>For a given origami <var class="Arg">O</var> and a word <var class="Arg">w</var> in <span class="SimpleMath">\(S\)</span> and <span class="SimpleMath">\(T\)</span> (given as a string), this methods computes the origami <span class="SimpleMath">\(w^{-1}.O\)</span>.</p>


<div class="example"><pre>
      
      gap&gt; O:= Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8);
      Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6), 8)
      gap&gt; ActionOfSL2("S*T", O);
      Origami((1,6,2,8,3,5,4), (3,4,7)(5,8,6), 8)
      
    </pre></div>

<p><a id="X80E9A8A7876A8E81" name="X80E9A8A7876A8E81"></a></p>

<h4>2.3 <span class="Heading">Equivalence of origamis and normal forms</span></h4>

<p>We consider two origamis to be equivalent (or isomorphic), if they are the same up to relabelling the squares. In terms of pairs of permutations, this corresponds to simultaneous conjugation. Equivalence can be checked by computing a certain normal form for origamis.</p>

<p><a id="X802D1FAC7A4431ED" name="X802D1FAC7A4431ED"></a></p>

<h5>2.3-1 OrigamiNormalForm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrigamiNormalForm</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>Computes a normal form of a given origami. This normal form has the property that two origamis are equivalent if and only if their normal form are equal. Note that this method does not copy any previously computed attributes from the old origami to the new one.</p>


<div class="example"><pre>
      
      gap&gt; O := Origami((1,3,2,4),(2,3));
      Origami((1,3,2,4), (2,3), 4)
      gap&gt; OrigamiNormalForm(O);
      Origami((1,2,3,4), (3,4), 4)
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CopyOrigamiInNormalForm</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>This method does the same as <code class="code">OrigamiNormalForm</code> but <em>does copy</em> previously computed attributes.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrigamisEquivalent</code>( <var class="Arg">O1</var>, <var class="Arg">O2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: Two origamis.</p>

<p>Checks whether two given origamis are equivalent by comparing their normal forms.</p>


<div class="example"><pre>
      
      gap&gt; P := Origami((1,2,3,4), (3,4), 4);
      Origami((1,2,3,4), (3,4), 4)
      gap&gt; O := Origami((1,3,2,4),(2,3));
      Origami((1,3,2,4), (2,3), 4)
      gap&gt; OrigamisEquivalent(O, P);
      true
      
    </pre></div>

<p><a id="X7A430F877A4960EF" name="X7A430F877A4960EF"></a></p>

<h4>2.4 <span class="Heading">Computing attributes of origamis</span></h4>

<p><a id="X7D4E90288408DB38" name="X7D4E90288408DB38"></a></p>

<h5>2.4-1 Stratum</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Stratum</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A (possibly empty) list of positive integers.</p>

<p>This function calculates the stratum of an origami, i.e. the list of the nonzero degrees of the singularities. For a singularity of cone angle <span class="SimpleMath">\(2 k \pi\)</span> the degree of the singularity is <span class="SimpleMath">\(k-1\)</span>.</p>


<div class="example"><pre>
      
      gap&gt; Stratum(Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6)));
      [ 1, 5 ]
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Genus</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A non-negative integer.</p>

<p>Calculates the genus of an origami.</p>


<div class="example"><pre>
    
    gap&gt; Genus(Origami((1,2,3,4), (1,2)(3,4)));
    2
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndexOfMonodromyGroup</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A positive integer.</p>

<p>Calculates the index of the monodromy group of an origami, i.e. the index of the subgroup generated by <span class="SimpleMath">\(\sigma_x\)</span> and <span class="SimpleMath">\(\sigma_y\)</span> in <span class="SimpleMath">\(S_d\)</span> where <span class="SimpleMath">\(d\)</span> is the degree of the origami.</p>


<div class="example"><pre>
    
    gap&gt; IndexOfMonodromyGroup(Origami((1,3,6)(4,5),(2,4,3,5)(7,1)));
    1
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VeechGroup</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A subgroup of <span class="SimpleMath">\(SL_2(\mathbb Z)\)</span>.</p>

<p>The Veech group of an origami is a finite-index subgroup of <span class="SimpleMath">\(SL_2(\mathbb{Z})\)</span>. In GAP it is is represented as a <code class="code">ModularSubgroup</code> from the <strong class="pkg">ModularGroup</strong> package. It is determined by two permutations <span class="SimpleMath">\(\sigma_S\)</span> and <span class="SimpleMath">\(\sigma_T\)</span> describing how the generators <span class="SimpleMath">\(S\)</span> and <span class="SimpleMath">\(T\)</span> of <span class="SimpleMath">\(SL_2(\mathbb{Z})\)</span> act on the cosets. See <a href="chapBib_mj.html#biBveech_alg_schmithuesen">[Sch04]</a> for a detailed description of the algorithm used to compute the Veech group.</p>


<div class="example"><pre>
    
    gap&gt; O := Origami((1,2,5)(3,4,6), (1,2)(5,6));
    Origami((1,2,5)(3,4,6), (1,2)(5,6), 6)
    gap&gt; G := VeechGroup(O);
    &lt;modular subgroup of index 10&gt;
    gap&gt; Display(G);
    ModularSubgroup(
    S : ( 1, 2)( 3, 6)( 4, 7)( 5, 8)( 9,10)
    T : ( 1, 3)( 2, 4, 5)( 6, 8,10, 9, 7)
    R : ( 1, 8, 7)( 2, 6)( 3, 4,10, 9, 5)
    J : ( 1, 5, 6)( 2, 3, 7)( 4, 9, 8) )
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VeechGroupAndOrbit</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A record.</p>

<p>Computes both the Veech group and the orbit under the <span class="SimpleMath">\(SL_2(\mathbb Z)\)</span> action of a given origami <var class="Arg">O</var>. Also returns the matrices with map the origami <var class="Arg">O</var> to the corresponding orbit elements. The returned record has the following format:</p>


<ul>
<li><p><em>VeechGroup</em> : the Veech group as a <code class="code">ModularSubgroup</code></p>

</li>
<li><p><em>orbit</em> : the <span class="SimpleMath">\(SL_2(\mathbb Z)\)</span>-orbit of <var class="Arg">O</var> as a list of <code class="code">Origami</code>s</p>

</li>
<li><p><em>matrices</em> : a list of matrices mapping <var class="Arg">O</var> to the corresponding orbit elements</p>

</li>
</ul>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeckGroup</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A group.</p>

<p>Computes the group of deck transformations of the origami <var class="Arg">O</var> as a covering of the once punctured torus. Note that the deck transformations can be seen as permutations of the squares of the origami.</p>


<div class="example"><pre>
    
    gap&gt; O := Origami((1,2,3,4,5), (), 5);
    Origami((1,2,3,4,5), (), 5)
    gap&gt; DeckGroup(O);
    Group([ (), (1,2,3,4,5), (1,3,5,2,4), (1,4,2,5,3), (1,5,4,3,2) ])
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementOfDeckGroup</code>( <var class="Arg">p</var>, <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A boolean.</p>

<p>Checks whether or not the permutation <var class="Arg">p</var> defines a deck transformation of the origami <var class="Arg">O</var>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNormalOrigami</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A boolean.</p>

<p>Checks whether or not a given origami is normal. An origami is called normal if its deck group acts transitively on the fibres of the covering.</p>


<div class="example"><pre>
    
    gap&gt; O := Origami((1,2,3,4,5), (), 5);
    Origami((1,2,3,4,5), (), 5)
    gap&gt; IsNormalOrigami(O);
    true
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SymplecticBasisOfHomology</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of words.</p>

<p>Computes a basis of the homology <span class="SimpleMath">\(H_1(O;\mathbb{Z})\)</span> that is symplectic with respect to the intersection form. The basis elements are represented as words in <span class="SimpleMath">\(x\)</span> and <span class="SimpleMath">\(y\)</span> which define closed paths starting from the square <span class="SimpleMath">\(1\)</span>.</p>


<div class="example"><pre>
    
    gap&gt; O := Origami((1,2),(2,3));
    Origami((1,2), (2,3), 3)
    gap&gt; SymplecticBasisOfHomology(O);
    [ x*y^2*x^-1, x*y^-2*x^-2*y^2*x^-1, x*y^-2*x^-1*y^-1*x*y^4*x^-1, x*y^-3*x^-1*y*x^-1 ]
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinStructure</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: <span class="SimpleMath">\(0\)</span> or <span class="SimpleMath">\(1\)</span></p>

<p>Computes the parity of the spin structure of <span class="SimpleMath">\(O\)</span>.</p>


<div class="example"><pre>
    
    gap&gt; O := Origami((1,2,3,4,5), (), 5);
    Origami((1,2,3,4,5), (), 5)
    gap&gt; SpinStructure(O);
    1
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SumOfLyapunovExponents</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: A positive Integer.</p>

<p>This function calculates the sum of the positive Lyapunov exponents of the Origami <var class="Arg">O</var>.</p>


<div class="example"><pre>
      
      gap&gt; O:=Origami((1,2,3,4,5,6,7,8,9),(1,3)(2,4,8)(5,7));
      Origami((1,2,3,4,5,6,7,8,9), (1,3)(2,4,8)(5,7), 9)
      gap&gt; SumOfLyapunovExponents(O);
      32/15
      
    </pre></div>

<p><a id="X838AD31B7BF71CDF" name="X838AD31B7BF71CDF"></a></p>

<h4>2.5 <span class="Heading">Normal Origamis</span></h4>

<p>Normal origamis can equivalently be described by a finite group <span class="SimpleMath">\(G\)</span> and a pair <span class="SimpleMath">\(x, y\)</span> of generators of <span class="SimpleMath">\(G\)</span>. The elements of <span class="SimpleMath">\(G\)</span> correspond to squares and the horizontal (resp. vertical) gluing is determined by left multiplication with <span class="SimpleMath">\(x\)</span> (resp. <span class="SimpleMath">\(y\)</span>), i.e. if <span class="SimpleMath">\(g,h \in G\)</span> then <span class="SimpleMath">\(g\)</span> is glued to <span class="SimpleMath">\(h\)</span> in the <span class="SimpleMath">\(x\)</span>-direction if <span class="SimpleMath">\(xg = h\)</span> and analogously for the <span class="SimpleMath">\(y\)</span>-direction. The group <span class="SimpleMath">\(G\)</span> is then evidently the deck group of the described origami. Furthermore, every normal origami is of this form where <span class="SimpleMath">\(G\)</span> is its deck group. Two normal origamis <span class="SimpleMath">\((x, y, G)\)</span>, <span class="SimpleMath">\((x',y',G)\)</span> given in such a form are equivalent if and only if there is an automorphism <span class="SimpleMath">\(\varphi \in \textrm{Aut}(G)\)</span> of <span class="SimpleMath">\(G\)</span> such that <span class="SimpleMath">\(\varphi(x) = x'\)</span> and <span class="SimpleMath">\(\varphi(y) = y'\)</span>. We introduce a new GAP-category called <code class="code">IsNormalStoredOrigami</code> which is a subcategory of the <code class="code">Origami</code>-category for representing normal origamis which are given in terms of the above data. Since every <code class="code">NormalStoredOrigami</code> is also an <code class="code">Origami</code>, every method implemented for <code class="code">Origami</code>s is also available for <code class="code">NormalStoredOrigami</code>s.</p>

<p><a id="X804339A77C4C3621" name="X804339A77C4C3621"></a></p>

<h5>2.5-1 NormalStoredOrigami</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalStoredOrigami</code>( <var class="Arg">x</var>, <var class="Arg">y</var>, <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A normal origami.</p>

<p>For a given finite group <var class="Arg">G</var> and two generators <var class="Arg">x, y</var> this method constructs a new normal origami in the way described above. It is given as a <code class="code">NormalStoredOrigami</code> object. This constructor checks whether or not <var class="Arg">G</var> is actually generated by <var class="Arg">x</var> and <var class="Arg">y</var>.</p>


<div class="example"><pre>
    
    gap&gt; G := AlternatingGroup(8);
    Alt( [ 1 .. 8 ] )
    gap&gt; gen := MinimalGeneratingSet(G);
    [ (1,2,3,4,5,6,7), (6,7,8) ]
    gap&gt; x := gen[1];; y := gen[2];;
    gap&gt; O := NormalStoredOrigami(x, y, G);
    Normal Origami( A_8.1^-1*A_8.2*A_8.1 , A_8.1^-1*A_8.2, Group( [ A_8.1, A_8.2 ]) )
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalStoredOrigamiNC</code>( <var class="Arg">x</var>, <var class="Arg">y</var>, <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A normal origami.</p>

<p>Does the same as the <code class="code">NormalStoredOrigami</code> constructor above but does not check whether or not <var class="Arg">G</var> is generated by <var class="Arg">x</var> and <var class="Arg">y</var>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HorizontalElement</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A group element.</p>

<p>For a <code class="code">NormalStoredOrigami</code>, this method returns the <span class="SimpleMath">\(x\)</span>-element which describes the gluing in the horizontal direction.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VerticalElement</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A group element.</p>

<p>For a <code class="code">NormalStoredOrigami</code>, this method returns the <span class="SimpleMath">\(y\)</span>-element which describes the gluing in the vertical direction.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsPermutationRepresentation</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>Converts a <code class="code">NormalStoredOrigami</code> into an <code class="code">Origami</code>, i.e. computes the <span class="SimpleMath">\(x\)</span>- and <span class="SimpleMath">\(y\)</span>-permutations describing the gluing of the squares.</p>


<div class="example"><pre>
    
    gap&gt; G := AlternatingGroup(4);
    Alt( [ 1 .. 4 ] )
    gap&gt; gen := MinimalGeneratingSet(G);
    [ (2,4,3), (1,3)(2,4) ]
    gap&gt; x := gen[1];; y := gen[2];;
    gap&gt; O := NormalStoredOrigami(x, y, G);
    Normal Origami( f1 , f2, Group( [ f1, f2, f3 ] ) )
    gap&gt; AsPermutationRepresentation(O);
    Origami((1,2,5)(3,6,9)(4,7,10)(8,11,12), (1,3)(2,7)(4,8)(5,12)(6,11)(9,10), 12)
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsPermutationRepresentation</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>Converts a normal <code class="code">Origami</code> into a <code class="code">NormalStoredOrigami</code>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllNormalOrigamisFromGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of normal origamis.</p>

<p>For a given group <var class="Arg">G</var>, this method computes all normal origamis (up to equivalence) which can be build from <var class="Arg">G</var>.</p>


<div class="example"><pre>
    
    gap&gt; G := AlternatingGroup(4);
    Alt( [ 1 .. 4 ] )
    gap&gt; AllNormalOrigamisFromGroup(G);
    [ Normal Origami( f3 , f1*f3, Group( [ f1, f2, f3 ] ) ),
    Normal Origami( f1 , f3, Group( [ f1, f2, f3 ] ) ),
    Normal Origami( f1 , f1*f3, Group( [ f1, f2, f3 ] ) ),
    Normal Origami( f1 , f1^2*f3, Group( [ f1, f2, f3 ] ) ) ]
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllNormalOrigamisByDegree</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of normal origamis.</p>

<p>Computes all normal origamis (up to equivalence) with degree <var class="Arg">d</var>.</p>


<div class="example"><pre>
    
    gap&gt; AllNormalOrigamisByDegree(5);
    [ Normal Origami( &lt;identity&gt; of ... , f1, Group( [ f1 ] ) ),
    Normal Origami( f1 , &lt;identity&gt; of ..., Group( [ f1 ] ) ),
    Normal Origami( f1 , f1, Group( [ f1 ] ) ),
    Normal Origami( f1 , f1^2, Group( [ f1 ] ) ),
    Normal Origami( f1 , f1^3, Group( [ f1 ] ) ),
    Normal Origami( f1 , f1^4, Group( [ f1 ] ) ) ]
    
    </pre></div>

<p><a id="X7AEE4C27789665DA" name="X7AEE4C27789665DA"></a></p>

<h4>2.6 <span class="Heading">Constructing examples of origamis</span></h4>

<p>In this section we describe some methods for constructing explicit examples and families of origamis. More examples of some special constructions of families of orgamis are given in Chapter <a href="chap7_mj.html#X7FC3D85F84DEFB5F"><span class="RefLink">7</span></a>.</p>

<p><a id="X818AFD7783755B39" name="X818AFD7783755B39"></a></p>

<h5>2.6-1 AllOrigamisByDegree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllOrigamisByDegree</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of origamis.</p>

<p>Returns a list of all origamis of degree <var class="Arg">d</var> up to equivalence.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllOrigamisInStratum</code>( <var class="Arg">d</var>, <var class="Arg">stratum</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of origamis.</p>

<p>Returns a list of all origamis of degree <var class="Arg">d</var> in the given stratum.</p>


<div class="example"><pre>
    
    gap&gt; OrigamiListInStratum(4, [1,1]);
    [ Origami((1,2), (1,3)(2,4), 4), Origami((1,2), (1,3,2,4), 4),
      Origami((1,2)(3,4), (2,3), 4), Origami((1,2)(3,4), (2,3,4), 4),
      Origami((1,2)(3,4), (1,2,3,4), 4), Origami((1,2,3), (2,3,4), 4),
      Origami((1,2,3), (2,4,3), 4), Origami((1,2,3), (1,2)(3,4), 4),
      Origami((1,2,3,4), (2,4), 4), Origami((1,2,3,4), (1,2)(3,4), 4) ]
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuasiRegularOrigami</code>( <var class="Arg">G</var>, <var class="Arg">H</var>, <var class="Arg">r</var>, <var class="Arg">u</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami.</p>

<p>The function calculates an origami by a given group <var class="Arg">G</var> and a subgroup of <var class="Arg">G</var> <var class="Arg">H</var>. <var class="Arg">H</var> must not contain any normal subgroups of G and <var class="Arg">r</var> and <var class="Arg">u</var> are the generators of G. We identify the tiles of the origami with the right cosets of H in G. The right neighbour of the tile <span class="SimpleMath">\(Hg\)</span> is the tile <span class="SimpleMath">\(Hgr\)</span> and the upper neighbour of <span class="SimpleMath">\(Hg\)</span> is <span class="SimpleMath">\(Hgu\)</span>.</p>


<div class="example"><pre>
      G:=SymmetricGroup(3);
      Sym( [ 1 .. 3 ] )
      gap&gt; H:=Group(());
      Group(())
      gap&gt;QuasiRegularOrigami(G,H,(1,2),(2,3));
      Origami((1,2)(3,5)(4,6), (1,3)(2,4)(5,6), 6)
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QROFromGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of origamis.</p>

<p>Returns a list of all quasi-regular origamis which can be build from the group <var class="Arg">G</var>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QROFromOrder</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of origamis.</p>

<p>Returns a list of all quasi-regular origamis of order <var class="Arg">d</var>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalformConjugators</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of permutations.</p>

<p>Calculates all permutations which yield a normal form when conjugated to the <var class="Arg">O</var>.</p>


<div class="example"><pre>
  gap&gt;origami:=Origami((1,2,3,4), (1,2)(3,4));
  Origami((1,2,3,4), (1,2)(3,4), 4)
  gap&gt;NormalformConjugators(origami);
  [ (), (1,3,2), (1,3)(2,4), (1,2,4) ]
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TranslationsOfOrigami</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of permutations.</p>

<p>Computes all translations of the origami as permutations of the squares of <var class="Arg">O</var>. This is equivalent to the permutations <span class="SimpleMath">\(t\)</span> which satisfy <span class="SimpleMath">\(t\circ \sigma_x\circ t^{-1} = \sigma_x\)</span> and <span class="SimpleMath">\(t\circ\sigma_y\circ t^{-1} = \sigma_y \)</span>, where <span class="SimpleMath">\(\sigma_x, \sigma_y\)</span> are the permutations describing the horizontal and the vertical gluing of the origami, respectively.</p>


<div class="example"><pre>
      gap&gt; origami:=Origami((1,2,3,4), (1,2)(3,4));
    Origami((1,2,3,4), (1,2)(3,4), 4)
    gap&gt; TranslationsOfOrigami(origami);
    [ (), (1,3)(2,4) ]
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHyperelliptic</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A boolean.</p>

<p>Tests whether an origami is hyperelliptic.</p>


<div class="example"><pre>
  gap&gt; origami:=Origami((1,2,3,4), (1,2)(3,4));
  Origami((1,2,3,4), (1,2)(3,4), 4)
  gap&gt; IsHyperelliptic(origami);
  true
  gap&gt; origami:=Origami((1,2,3,4,5,6), (1,2)(3,4)(5,6));
  Origami((1,2,3,4,5,6), (1,2)(3,4)(5,6), 6)
  gap&gt; IsHyperelliptic(origami);
  false
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PointReflectionsOfOrigami</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of permutations.</p>

<p>Computes all point reflections of <span class="SimpleMath">\(O\)</span>, i.e. all affine homeomorphisms with derivative <span class="SimpleMath">\(-I \)</span>, where <span class="SimpleMath">\(I\)</span> is the identity matrix. This is equivalent to the permutations <span class="SimpleMath">\( t \)</span> which satisfy <span class="SimpleMath">\(t\circ\sigma_x\circ t^{-1}=\sigma_x^{-1}\)</span> and <span class="SimpleMath">\(t\circ \sigma_y\circ t^{-1}=\sigma_y^{-1}\)</span>, where <span class="SimpleMath">\(\sigma_x,\sigma_y\)</span> are the permutations describing the horizontal and the vertical gluing of the origami, respectively.</p>


<div class="example"><pre>
          gap&gt; o:=Origami((1,2,3,4),(1,2)(3,4));
          Origami((1,2,3,4), (1,2)(3,4), 4)
          gap&gt; PointReflectionsOfOrigami(o);
          [ (1,2)(3,4), (1,4)(2,3) ]
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismsOfOrigami</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: Two lists consisting of two entries: The first entry is a list of permutations and the second entry is 1 resp. -1.</p>

<p>Computes all automorphisms of the origami, i.e. the translations and the point reflections. More precisely it returns two lists. The first list contains the translations and is labelel with 1. The second list contains the point reflections and is labeled with -1.</p>


<div class="example"><pre>
          gap&gt; o:=Origami((1,2,3,4),(1,2)(3,4));
          Origami((1,2,3,4), (1,2)(3,4), 4)
          gap&gt; AutomorphismsOfOrigami(o);
          [ [ [ (), (1,3)(2,4) ], 1 ], [ [ (1,2)(3,4), (1,4)(2,3) ], -1 ] ]
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FixedPointsOfPointReflections</code>( <var class="Arg">O</var>, <var class="Arg">sigma</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of fixed points. The fixed points are given as lists with three entries.</p>

<p>This function computes the fixed points of a point reflection <span class="SimpleMath">\(\sigma\)</span> of the origami <span class="SimpleMath">\(O\)</span> given as permutation of its squares. The function does not check whether <span class="SimpleMath">\(\sigma\)</span> is a point reflection, i.e. whether it satisfies <span class="SimpleMath">\(\sigma\circ\sigma_x\circ \sigma^{-1}=\sigma_x^{-1}\)</span> and <span class="SimpleMath">\(\sigma\circ \sigma_y\circ \sigma^{-1}=\sigma_y^{-1}\)</span>. The fixed points are returned in a list with entries <span class="SimpleMath">\([a,b,c]\)</span>, where <span class="SimpleMath">\(a\)</span> is the square in which the fixed point occurs and <span class="SimpleMath">\((b,c)\)</span> are the local coordinates in the square <span class="SimpleMath">\(a\)</span> and for the lower left corners <span class="SimpleMath">\(a\)</span> is a representative of the connected lower left corners.</p>


<div class="example"><pre>
      
      gap&gt; origami:=Origami((1,2,3,4),(1,2)(3,4));
      Origami((1,2,3,4), (1,2)(3,4), 4)
      gap&gt; sigma:=PointReflectionsOfOrigami(origami)[1];
      (1,2)(3,4)
      gap&gt; FixedPointsOfPointReflections(origami, sigma);
      [ [ 2, 0, 0.5 ], [ 4, 0, 0.5 ], [ 1, 0.5, 0 ], [ 2, 0.5, 0 ], [ 3, 0.5, 0 ], [ 4, 0.5, 0 ] ]
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FixedPointsOfTranslation</code>( <var class="Arg">O</var>, <var class="Arg">sigma</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of fixed points. The fixed points are given as lists of vertices.</p>

<p>This function computes the fixed points of a translation <span class="SimpleMath">\(\sigma\)</span> of the origami <span class="SimpleMath">\(O\)</span> given as permutations of its squares. The function does not check whether <span class="SimpleMath">\(\sigma\)</span> is a translation, i.e. whether it satisfies <span class="SimpleMath">\(\sigma\circ\sigma_x\circ \sigma^{-1}=\sigma_x\)</span> and <span class="SimpleMath">\(\sigma\circ \sigma_y\circ \sigma^{-1}=\sigma_y\)</span>. The fixed points of a translation are always vertices of the squares. Each fixed point is returned as list of vertices, more precisely as the labels of all squares such that the corresponding vertex is the fixed point.</p>


<div class="example"><pre>
      
            gap&gt; origami:=Origami((1,2,3,4),(1,2)(3,4));
      Origami((1,2,3,4), (1,2)(3,4), 4)
      gap&gt; TranslationsOfOrigami(origami);
      [ (), (1,3)(2,4) ]
      gap&gt; sigma:=TranslationsOfOrigami(origami)[2];
      (1,3)(2,4)
      gap&gt; FixedPointsOfTranslation(origami, sigma);
      [ [ 1, 3 ], [ 2, 4 ] ]
    
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FixedPointsOfAutomorphism</code>( <var class="Arg">O</var>, <var class="Arg">sigma</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of fixed points. The fixed points are presened in the format corresponding of the type, i.e. the format depends on whether the automorphism is a translation or a point reflection.</p>

<p>This function computes the fixed points of an automorphism <span class="SimpleMath">\(\sigma\)</span> of the origami <span class="SimpleMath">\(O\)</span>. If sigma is a point reflection, the fixed points are returned in a list with entries <span class="SimpleMath">\([[a,b,c],d]\)</span>, where <span class="SimpleMath">\(a\)</span> is the square in which the fixed point occurs, <span class="SimpleMath">\((b,c)\)</span> are the local coordinates in the square and <span class="SimpleMath">\(d\)</span> is <span class="SimpleMath">\(-1\)</span>. If <span class="SimpleMath">\(\sigma\)</span> is a translation it is returned as list of vertices labeled with 1.</p>


<div class="example"><pre>
      
      gap&gt; O:=Origami((1,2,3,4),(1,2)(3,4));
      Origami((1,2,3,4), (1,2)(3,4), 4)
      gap&gt; sigma:=(1,3)(2,4);
      (1,3)(2,4)
      gap&gt; FixedPointsOfAutomorphism(O,sigma);
      [ [ [ 1, 3 ], [ 2, 4 ] ], 1 ]
  
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GenusOfQuotient</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>For a given origami this function computes the genus of the quotient <span class="SimpleMath">\( O/Trans(O) \)</span>, where <span class="SimpleMath">\(Trans(O)\)</span> is the translation group.</p>


<div class="example"><pre>
      
      gap&gt; O:=Origami((1,2,3)(4,5,6),(3,4));
      Origami((1,2,3)(4,5,6), (3,4), 6)
      gap&gt; GenusOfQuotient(O);
      1
      
    </pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrigamiQuotient</code>( <var class="Arg">O</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An origami</p>

<p>For a given origami this function computes the quotient origami <span class="SimpleMath">\( O/Trans(O) \)</span>, where <span class="SimpleMath">\(Trans(O)\)</span> is the translation group.</p>


<div class="example"><pre>
      
      gap&gt; O:=Origami((1,2,3)(4,5,6),(3,4));
      Origami((1,2,3)(4,5,6), (3,4), 6)
      gap&gt; OrigamiQuotient(O);
      Origami((1,2,3), (), 3)
      
    </pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
