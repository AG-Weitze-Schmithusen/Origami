<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE Book SYSTEM "gapdoc.dtd">
<Book Name="Origami Package">

<TitlePage>
  <Title>The <Package>Origami</Package> Package</Title>
  <Subtitle>Computing Veechgroups of Origamis</Subtitle>
  <Date>13.11.2018</Date>
  <Version>Version 1.0.0</Version>
  <Author>Pascal Kattler
    <Email>kattler@math.uni-sb.de</Email>
    <Homepage>http://www.math.uni-sb.de/ag/weitze/</Homepage>
    <Address>
      AG Weitze-Schmithüsen<Br/>
      FR 6.1 Mathematik<Br/>
      Universität des Saarlandes<Br/>
      D-66041 Saarbrücken<Br/>
    </Address>

  </Author>
  <Author>Andrea Thevis
    <Email>thevis@math.uni-sb.de</Email>
    <Homepage>http://www.math.uni-sb.de/ag/weitze/</Homepage>
    <Address>
      AG Weitze-Schmithüsen<Br/>
      FR 6.1 Mathematik<Br/>
      Universität des Saarlandes<Br/>
      D-66041 Saarbrücken<Br/>
    </Address>
  </Author>

    <Copyright>&copyright; 2018 by Pascal Kattler
    </Copyright>

    <Acknowledgements>
We thank Sergio Siccha for his support and valuable input at the
beginning of this project. Further, we would like to thank Vincent
Delecroix and Samuel Lelièvre for fruitful discussions about algorithms
implemented in the surface_dynamics package in sage. Some of the
functionality of the surface_dynamics package can be used in this
package as well. For this we use an interface between &GAP; and sage. We
are thankful to Mohamed Barakat and Markus Pfeiffer for helping using
the interfaces. Moreover, we thank Thomas Breuer for helpful ideas and comments on some
algorithms implemented in this package.

<Par/>

This software package is part of the project I.8 'Algorithmic approaches to Teichmüller curves' 
(AG Weitze, Saarland University) supported by SFB-TRR 195 'Symbolic Tools in 
Mathematics and their Application' of the German Research Foundation (DFG). 
    </Acknowledgements>


  </TitlePage>

<TableOfContents/>

<Body>
<Chapter> <Heading> Introduction </Heading>
  <Section> <Heading>Overview</Heading>
    <!--<Section Label="sec:theory"> <Heading>Introduction</Heading> -->
    This package provides calculations with a certain class of translation surfaces called origamis. An origami (also known as square-tiled surface) 
    is a finite covering of a torus which is ramified at most over one point. It can be described in the following way from
    two permutations <M>\sigma_x, \sigma_y \in S_d</M>. We take <M>d</M> squares <M>Q_1, \dots, Q_d</M> and glue the lower side of
    <M>Q_i</M> to the upper side of <M>Q_{\sigma_y(i)}</M> and the right side of <M>Q_i</M> to the left side of <M>Q_{\sigma_x(i)}</M>.
    We require origamis to be connected and thus the group generated by <M>\sigma_x</M> and <M>\sigma_y</M>  acts transitively on <M>\{1,\dots,d\}</M>.
    In this package we identify an origami with a pair of permutations, which acts transitively on <M>\{1, \dots, d\}</M> up
    to simultaneous conjugation. This corresponds to renumbering the labels of the squares. By choosing a certain numbering in a canonical way one can 
    achieve a canonical representative.

<Par/>

    In this package we are mainly interested in Veech groups of origamis. They are subgroups of finite index of 
    <M>SL_2(\mathbb{Z})</M> which carry a lot of information about the geometric and dynamic properties of the underlying translation surface. 
    For further information about origamis and translation surfaces in general see e.g.<Cite Key = "PHD1" />, <Cite Key = "PHD2" />, <Cite Key = "MR2214127" />, <Cite Key = "Lec" /> and <Cite Key = "MR2261104" />.
</Section>
<Section> <Heading> Notations </Heading>
    Since we are mainly interested in the Veech group of an origami, which are a subgroups of <M>SL_2(\mathbb{Z})</M> of finite index,
 we fix two generators of <M>SL_2(\mathbb{Z})</M>
    <Display>
      S =
     \left( {\begin{array}{cc}
      0 &amp; -1 \\
      1 &amp; 0 \\
     \end{array} } \right)
   </Display>

    and

    <Display>
      T =
     \left( {\begin{array}{cc}
      1 &amp; 1 \\
      0 &amp; 1 \\
     \end{array} } \right).
   </Display>




    In this package we fix the free group <M>F</M> generated by <M>\tilde{S}</M> and <M>\tilde{T}</M>.
    We consider the canonical epimorphism <M>\pi: F\to SL_2(\mathbb{Z})</M> with <M>\pi(\tilde{S})=S</M> and <M>\pi(\tilde{T})=T</M>.




</Section>
</Chapter>
<Chapter> <Heading> The functionality of this package </Heading>
    <Section> <Heading>The Origami Object</Heading>
      
    In this section we introduce a new type called 'origami', namely origami objects, which are created
    by two permutations. The degree of an origami is the number of squares. Origamis are stored as such objects.


<Br/>

<ManSection>
      

  <Func Name="Origami" Arg="permX , permY"/>
 <Returns>An Origami.</Returns>
        <Description>
		This function generates a new origami object with <M> \sigma_x =</M> <Arg> permX </Arg>, <M> \sigma_y =</M> <Arg> permY </Arg>. 
                The function tests whether (<Arg> permX </Arg>,<Arg> permY </Arg>) defines a connected surface and returns false otherwise.
        <Example>
gap> Origami((1,2), (2,3));
Origami((1,2), (2,3), 3)
        </Example>
        </Description>

 <Func Name="OrigamiNC" Arg="permX , permY, d"/>
 <Returns>An Origami.</Returns>
  <Description>
This function does the same as <Ref Func="Origami"/>, but in contrast it does not test,
    whether the origami describes a connected surface. <Br/>
  </Description>



<Func Name="OrigamiNormalForm" Arg="origami"/>
 <Returns>An Origami.</Returns>
<Description>
          This function calculates a canonical representation of <Arg> origami</Arg>. Two origamis are equivalent, if they have the same canonical representation. This function has been implemented by Luca Junk and the algorithm is from <Cite Key = "ONF" />.
<Example>
gap> OrigamiNormalForm(Origami((1,3,5,7)(2,8,4,10)(6,9), 
>(1,5,2,6,3)(4,10)(7,9) ));
Origami((1,2)(3,5,4,6)(7,8,9,10), (1,3)(2,4,5,6,7)(9,10), 10)
</Example>
</Description>

        <Fam Name="OrigamiFamily"/>
        <Description>
          Since origamis do not fit in any existing family in &GAP;, we introduce a new family for origami objects called OrigamiFamily. <Br/>
        </Description>


        <Attr Name="HorizontalPerm" Arg="origami"/>
 		<Returns>A permutation.</Returns>
        <Description>
           This function returns the horizontal permutation <M>\sigma_y</M> of an origami.
<Example>
gap> HorizontalPerm(Origami((1,3,5), (1,3)(2,4,5)));
(1,3,5)
</Example>
        </Description>

        <Attr Name="VerticalPerm" Arg="origami"/>
		<Returns>A permutation.</Returns>
        <Description>
            This function returns the vertical permutation <M>\sigma_x</M> of an origami.
<Example>
gap> VerticalPerm( Origami((1,3,5), (1,3)(2,4,5) ));
(1,3)(2,4,5)
</Example>
        </Description>

        <Attr Name="DegreeOrigami" Arg="origami"/>
 		<Returns>An Int.</Returns>
        <Description>
        This function returns the degree of an origami.
<Example>
gap> DegreeOrigami(Origami((1,3,5), (1,3)(2,4,5) ));
5
</Example>
        </Description>

        <Attr Name="Stratum" Arg="origami"/>
		 <Returns>A list of Ints.</Returns>
        <Description>
           This function calculates the stratum of an origami. The stratum of an origami is a list of the nonzero degrees
           of the singularities. For a singularity of cone angle <M>2\pi k</M> the degree of the singularity is <M>k-1</M>.
<Example>
gap> Stratum(Origami((1,6,4,7,5,3)(2,8), (1,4,5,3,8,2,6) ));
[ 1, 5 ]
</Example>
        </Description>

        <Attr Name="Genus" Arg="origami"/>
		 <Returns>An Int.</Returns>
        <Description>
         This function calculates the genus of the origami surface.
<Example>
gap> Genus( Origami((1,2,3,4),(1,2)(3,4) ) );
2
</Example>
        </Description>
</ManSection>

</Section>
<Section> <Heading><M>SL_2(\mathbb{Z})</M>-Action on Origamis</Heading>


        The group <M>SL_2(\mathbb{Z}) </M> acts on the set of origamis of fixed degree. The following methods help calculating this 
        operation both for matrices and words in the free group <M>F</M>.

<Br/>


<ManSection> <Heading> Actions </Heading>
<Meth Name="ActionOfSpecialLinearGroup" Arg="word, origami"/>
		 <Returns>An Origami object.</Returns>
        <Description>
          Given a word <Arg>word</Arg> in the free group  <M>F=</M> <M>Group(\tilde{S}, \tilde{T})</M> this function computes
          <M>\pi(<Arg>word</Arg>) \in SL_2(\mathbb{Z})</M> and returns <M>\pi(<Arg>word</Arg>).<Arg>origami</Arg></M>. The word is given
          as a string, as shown in the following example.
<Example>
gap> ActionOfSpecialLinearGroup("ST",Origami((1,3,5), (1,3)(2,4,5)));
Origami((1,3)(2,5,4), (2,4,5,3), 5)
</Example>
        </Description>
		 
        <Meth Name="ActionOfSpecialLinearGroup" Arg="matrix, origami"/>
        <Returns>An Origami.</Returns>
		<Description>
          Given matrix in <M>SL_2(\mathbb{Z}) </M> this function returns <Arg>matrix</Arg>.<Arg>origami</Arg>. 
<Example>
gap> ActionOfSpecialLinearGroup([ [ 0, -1 ], [ 1, 1 ] ], Origami((1,3,5), 
>(1,3)(2,4,5))); 
Origami((1,3)(2,5,4), (2,4,5,3), 5)
</Example>
        </Description>

<Func Name="ActionOfF2ViaCanonical" Arg="origami, word"/>
<Returns>An Origami.</Returns>
<Description>
 Given a word <Arg>word</Arg> in the free group  <M>Group(\tilde{S}, \tilde{T})</M> this function computes
 <M>\pi(<Arg>word</Arg>) \in SL_2(\mathbb{Z})</M> and returns <M>\pi(<Arg>word</Arg>).<Arg>origami</Arg></M>.
 But in contrast to <Ref Func="ActionOfSpecialLinearGroup"/> the result is stored in the canonical representation.
 ATTENTION: the order of arguments is switched compared to the order of the arguments in the function <Ref Func="ActionOfSpecialLinearGroup"/>.
  <Example>
gap> ActionOfF2ViaCanonical(Origami((1,2), (1,3)), "S");
Origami((1,2), (2,3), 3)
  </Example>
</Description>

<Func Name="RightActionOfF2ViaCanonical" Arg="origami, word"/>
 <Returns>An Origami.</Returns>
<Description>
  This function computes the right action of the projection of a word <Arg>word</Arg> in the free group <M>Group(\tilde{S}, \tilde{T})</M> on an origami <Arg>origami</Arg>.
 It returns <M><Arg>origami</Arg>.\pi(<Arg>word</Arg>) = \pi(<Arg>word</Arg>)^-1.<Arg>origami</Arg></M>, where the left action
 is the common action of <M>SL_2(\mathbb{Z})</M> on origamis of a given degree. This action has
 the same orbits as the left action. For the Veech group computation both actions
 can be used and give the same result. In contrast to
 <Ref Func="ActionOfSpecialLinearGroup" /> the result is stored in the canonical representation.
 ATTENTION: the order of arguments is switched compared to the order of the arguments in the function <Ref Func="ActionOfSpecialLinearGroup" />.
 <Example>
gap> RightActionOfF2ViaCanonical(Origami((2,3), (1,3,2)),"T");
Origami((1,2), (2,3), 3)
</Example>
</Description>
</ManSection>





</Section>
<Section> <Heading>Veech groups</Heading>

           The Veech group <M>G</M> of an origami is a subgroup <M>SL_2(\mathbb{Z})</M> of finite index. The group is 
           stored as a ModularSubgroup from the <Package>ModularSubgroup</Package>
           package. It is represented by two permutations <M>\sigma_S</M> and <M>\sigma_T</M> describing how the generators
           <M>S</M> and <M>T</M> of <M>SL_2(\mathbb{Z})</M> act on the cosets of <M>G</M> in <M>SL_2(\mathbb{Z})</M>.
           E.g, if <M>SH_i = H_j</M> and <M>H_i,H_j</M> are the cosets associated to integers <M>i,j</M>, respectively, then
           <M>\sigma_S(i)=j</M>.

           See <Cite Key="MR2118271"/> for a detailed version of the algorithm.

<Par/>

<ManSection>
        <Attr Name="VeechGroup" Arg="origami"/>
		 <Returns>A ModularSubGroup.</Returns>
        <Description>
           This function calculates the Veech group of an origami. 

           You get the coset permutations using the <Package>ModularSubgroup</Package> package as in the following example.
        <Example>
gap> SAction(VeechGroup(Origami((1,2,5)(3,4,6), (1,2)(5,6) )));
(1,3)(2,5)(4,7)(6,8)(9,10)
gap> TAction(VeechGroup(Origami((1,2,5)(3,4,6), (1,2)(5,6) )));
(1,2,4)(3,6)(5,8,7,9,10)
        </Example>
        </Description>

        <Attr Name="Cosets" Arg="origami"/>
		 <Returns>A list of element of the free group with generators S and T.</Returns>
        <Description>
           This function calculates the right cosets of the Veech group of an origami as a list of words in <M>S</M>
           and <M>T</M>.
<Example>
gap> Cosets(Origami((1,2,5)(3,4,6), (1,2)(5,6), 6));
[ &lt;identity ...>, S, T, T^-1, S*T, S*T^-1, T*S, T^-1*S, S*T*S, S*T^-1*S ]
</Example>
        </Description>

        <Func Name="EquivalentOrigami" Arg="origami1, origami2"/>
		 <Returns>A boolean.</Returns>
        <Description>
          This function tests whether <Arg>origami1</Arg> is equal  to <Arg>origami2</Arg> up to renumbering of the squares.
<Example>
gap> EquivalentOrigami(Origami((1,4)(2,6,3), (1,5)(2,3,6,4) ), Origami((1,4,3)
>(2,5), (1,5,3,4)(2,6) ));
true

gap> EquivalentOrigami(Origami((1,4)(2,6,3), (1,5)(2,3,6,4) ), Origami((1,2,5)
>(3,4,6), (1,2)(5,6) ));
false
</Example>
</Description>
</ManSection> 
At this point we thank Thomas Breuer for the idea how to implement the  latter function.


</Section>
<Section> <Heading>Lists of Origamis</Heading>
The following functions generate lists of origamis of a given degree (and stratum). 

<Br/>

<ManSection>
<Func Name="OrigamiList" Arg="d"/>
 <Returns>A list of Origamis.</Returns>
<Description>
	This function calculates a list of all origamis with a given degree <Arg>d</Arg>. 
<Example>
gap> OrigamiList(2);
[ Origami((), (1,2), 2), Origami((1,2), (), 2), Origami((1,2), (1,2), 2) ]
</Example>
</Description>


<Func Name="OrigamiListWithStratum" Arg="d, stratum"/>
 <Returns>A list of Origamis.</Returns>
<Description>
	This function calculates a list of all origamis with a given degree <Arg>d</Arg> and stratum <Arg>stratum</Arg>.
<Example>
gap> OrigamiListWithStratum(5, [1,1]);
[ Origami((1,2), (1,3)(2,4,5), 5), Origami((1,2), (1,3,2,4,5), 5), 
  Origami((1,2,3), (1,2)(3,4,5), 5), Origami((1,2,3), (2,3,4,5), 5), 
  Origami((1,2,3), (2,4,5,3), 5), Origami((1,2)(3,4,5), (2,3), 5), 
  Origami((1,2)(3,4,5), (1,2,3), 5), Origami((1,2)(3,4,5), (2,3,4,5), 5), 
  Origami((1,2)(3,4,5), (2,3,5,4), 5), Origami((1,2)(3,4,5), (1,2,3,4,5), 5), 
  Origami((1,2)(3,4,5), (1,2,3,5,4), 5), Origami((1,2,3,4), (3,4,5), 5), 
  Origami((1,2,3,4), (3,5,4), 5), Origami((1,2,3,4), (1,2,3)(4,5), 5), 
  Origami((1,2,3,4), (1,3,2)(4,5), 5), Origami((1,2,3,4), (2,3,4,5), 5), 
  Origami((1,2,3,4), (2,5,4,3), 5), Origami((1,2,3,4), (1,2,4,5,3), 5), 
  Origami((1,2,3,4), (1,3,5,4,2), 5), Origami((1,2,3,4,5), (3,5), 5), 
  Origami((1,2,3,4,5), (1,2)(3,4,5), 5), Origami((1,2,3,4,5), (1,2)(3,5,4), 5)
    , Origami((1,2,3,4,5), (2,4,3,5), 5), Origami((1,2,3,4,5), (2,5,3,4), 5) ]
</Example>
</Description>
</ManSection>

</Section>
</Chapter>
<Chapter> <Heading> Deck group and normal origamis </Heading>
<Section> <Heading> The deck group of origamis </Heading>
	Since origamis are covers of the one-punctured torus, we can also calcultate deck transformations and the deck group of an origami. Deck transfromations map any point <M> x </M> of any square <M> Q_i </M> to the corresponding point of the square <M> Q_j </M> for some <M> j </M>. So, deck transformations of an origami map squares to squares. We will store a deck transformation as permutation <M> \sigma </M>, in which <M> \sigma(i) = j </M> if the corresponding deck transformation maps the square <M> Q_i </M> to <M> Q_j </M>. This package provides the following functions.

<ManSection> <Heading> Deck transformations </Heading>
<Attr Name="DeckGroup" Arg="origami"/>
 <Returns>A list of permutation.</Returns>
<Description>
	This method calculates the deck group of an <Arg>origami</Arg> and returns a list of permutations, in which the deck transformation, associated to the permutation <M> \sigma </M>, maps the square <M> Q_i </M> to the square <M> Q_j </M>, if <M> \sigma(i) = j </M>. Note that the describtion of the deck transformations depends on the numbering of the squares of the origami. In order to make the permutations unique, you should use <Ref Func = "OrigamiNormalForm" />.
<Example>
gap> DeckGroup( Origami( (1,2)(3,4)(5,6), (1,3)(2,5)(4,6)) );
[ (), (1,2)(3,5)(4,6), (1,3)(2,4)(5,6), (1,4,5)(2,3,6), (1,5,4)(2,6,3), 
  (1,6)(2,5)(3,4) ]
</Example>
</Description>

<Func Name = "IsElementOfDeckGroup" Arg= "origami, sigma " />
<Returns> A boolean, </Returns>
<Description>
This function tests, wether the permutation <Arg> sigma </Arg> describes a deck transformation of the <Arg> origami </Arg>. This function is used for <Ref Attr = "DeckGroup"/>.
<Example>
gap> IsElementOfDeckGroup( Origami( (1,2)(3,4)(5,6), (1,3)(2,5)(4,6)), 
(1,2)(3,5)(4,6) );
true
</Example>
</Description>
</ManSection>

An origami is normal, if there is for any <M> i \in \{1, \dots, d\} </M> a deck transformation that maps <M> Q_1 </M> to <M> Q_i </M>, i.e. the length of the deck group is equal the degree <M> d </M> of the origami. The following attribute tests, wether a given origami is normal.

<ManSection>
<Attr Name="IsNormalOrigami" Arg="origami"/>
 <Returns>A boolean.</Returns>
<Description>
	This method tests wether a given <Arg> origami </Arg> is normal.
<Example>
gap> IsNormalOrigami( Origami( (1,2)(3,4)(5,6)(7,8), (1,3)(2,5)(4,7)(6,8) ) ); 
true 
</Example>
</Description>
</ManSection>

</Section>
 </Chapter>
<Chapter> <Heading> SageMath functions </Heading>
<Section> <Heading> Using SageMath functions</Heading>
The SageMath Package surface_dynamics from Vincent Delecroix <Cite Key="Delecroix"/> provides functions to study origamis.
To use the functions of this chapter, Sage and the surface_dynamics package must be installed on your operation system. Furthermore, the &GAP; packages 
<Package>homalgto</Package>, <Package>io_forhomalg</Package>, <Package>io</Package> and <Package>rings</Package> must be installed.


<Br/>



The following descriptions and examples 
are mainly taken from the manual of <Cite Key="Delecroix"/>.

<Br/>

<ManSection> <Heading> SageMath </Heading>
<Func Name="VeechgroupBySage" Arg="origami"/>
 <Returns>A ModularSubGroup.</Returns>
<Description>
	This function executes the SageMath method veech_group to <Arg>origami</Arg> and returns its result as &GAP; object. It does the same as <Ref Func="VeechGroup"/>.
<Example>
gap> VeechgroupBySage(Origami((1,3,5), (1,3)(2,4,5) ));
&lt;modular subgroup of index 24>

</Example>
</Description>

<Func Name="NormalFormBySage" Arg="origami"/>
 <Returns>An Origami.</Returns>
<Description>
	This function executes the SageMath method to_standard_form to <Arg>origami</Arg> and returns its result as &GAP; object. 
In principle, it calculates a canonical representative by changing the numbering of the squares like the function <Ref Func="OrigamiNormalForm"/>. 
But it chooses another representation.
<Example>
gap> NormalFormBySage(Origami((1,3,5), (1,3)(2,4,5) ));
Origami((3,4,5), (1,2,3)(4,5), 5)
</Example>
</Description>
<Func Name="IsHyperellipticBySage" Arg="origami"/>
 <Returns>A boolean.</Returns>
<Description>
	This function executes the SageMath method IsHyperelliptic to <Arg>origami</Arg> and returns its result as &GAP; object. It tests, weather <Arg>origami</Arg> is hyperelliptic.
<Example>
gap> IsHyperellipticBySage(Origami((1,3), (1,2) ));                                                                                           
true
</Example>
</Description>

<Func Name="IsPrimitiveBySage" Arg="origami"/>
 <Returns>A boolean.</Returns>
<Description>
	This function executes the SageMath method IsPrimitive to <Arg>origami</Arg> and returns its result as &GAP; object. An origami is primitive if it does not cover an other origami.
	An origami is primitive if the action of the monodromy group has no
   non trivial block.
<Example>
gap> IsPrimitiveBySage(Origami((1,3), (1,2) ));
true
gap> IsPrimitiveBySage(Origami((1,2)(3,4), (1,3,5,6)(2,4) ));
false
</Example>
</Description>

<Func Name="ReduceBySage" Arg="origami"/>
 <Returns>An Origami.</Returns>
<Description>
	This function executes the SageMath method Reduce to <Arg>origami</Arg> and returns its result as &GAP; object. It returns a reduced origami isomorphic (up to <M>SL(2,\mathbb{Q})</M> action) to that origami.
<Example>
gap> ReduceBySage(Origami((1,2)(3,4), (1,3,5,6)(2,4) ));
Origami((1,2), (1,3), 6)
</Example>
</Description>

<Func Name="AbsolutePeriodGeneratorsBySage" Arg="origami"/>
 <Returns>A list of lists of Ints.</Returns>
<Description>
	This function executes the SageMath method AbsolutePeriodGenerators to <Arg>origami</Arg> and returns its result as &GAP; object. It return a generating set of the absolute periods of this origami.
	To each curve on an origami, we can associate its holonomy (that is
   an element of <M> \mathbb{Z} \times \mathbb{Z}</M>). This function returns a generating
   set of the module generated by holonomies of closed curves.
<Example>
gap> AbsolutePeriodGeneratorsBySage(Origami((1,2,3,4)(5,6), (1,5)(2,6) )); 
[ [ 2, 0 ], [ 2, 0 ], [ 0, 1 ], [ 0, 1 ] ]
</Example>
</Description>

<Func Name="LatticeOfAbsolutePeriodsBySage" Arg="origami"/>
<Returns>A list of lists of Ints.</Returns>
<Description>
	This function executes the SageMath method LatticeOfAbsolutePeriods to <Arg>origami</Arg> and returns its result as &GAP; object. It returns (a,t,u) where ((a,0),(t,u)) is a standard basis for the
   lattice of the absolute periods of self.
	The lattice of periods of an origami is the sublattice of <M> \mathbb{Z}^2</M>
   generated by the holonomy vectors of its saddle connections. Any
   sublattice of <M> \mathbb{Z}^2</M> has a standard basis consisting of a horizontal
   vector (a,0) and a nonhorizontal vector (t,u), where a, t, u are
   integers satisfying 0 &lt; t &lt; a and 0 &lt; t.
<Example>
gap> LatticeOfAbsolutePeriodsBySage(Origami((1,2)(3,4), (2,3) ));   
[ [ 2, 0 ], [ 0, 1 ] ]
</Example>
</Description>


<Func Name="OptimalDegreeBySage" Arg="origami"/>
<Returns>An Int.</Returns>
<Description>
	This function executes the SageMath method OptimalDegree to <Arg>origami</Arg> and returns its result as &GAP; object. The optimal degree of self is the degree of the map to the largest
   torus.
   Any origami <M>X \rightarrow T</M> factor as <M>i \circ \pi_{opt}</M> where i is an
   isogeny. The optimal degree is the degree of <M>\pi_{opt}</M>.

<Example>
gap> OptimalDegreeBySage(Origami((1,2)(3,4), (2,3) ));
2
</Example>
</Description>

<Func Name="PeriodGeneratorsBySage" Arg="origami"/>
<Returns>A list of lists of Ints.</Returns>
<Description>
	This function executes the SageMath method PeriodGenerators to <Arg>origami</Arg> and returns its result as &GAP; object. It return a list of periods that generate the lattice of periods.
<Example>
gap> PeriodGeneratorsBySage(Origami((1,3,6)(2,5,7)(4),(1,2,4,3,5,6,7) ));    
[ [ 2, 0 ], [ 1, 0 ], [ 1, 0 ], [ 0, 2 ], [ -1, 2 ], [ 0, 1 ] ]
</Example>
</Description>

<Func Name="WidthsAndHeightsBySage" Arg="origami"/>
<Returns>A list of lists of Ints.</Returns>
<Description>
	This function executes the SageMath method WidthsAndHeights to <Arg>origami</Arg> and returns its result as &GAP; object. It return the list of widths and heigths of cylinder.
<Example>
gap> WidthsAndHeightsBySage(Origami((1,2)(3,4),(1,3,5,6)(2,4) ));        
[ [ 1, 2 ], [ 2, 2 ] ]
</Example>
</Description> 

<Func Name="SumOfLyapunovExponentsBySage" Arg="origami"/>
<Returns>A rational number.</Returns>
<Description>
	This function executes the SageMath method SumOfLyapunovExponents to <Arg>origami</Arg> and returns its result as &GAP; object.
 It returns the sum of Lyapunov exponents for this origami.
<Example>
gap> SumOfLyapunovExponentsBySage(Origami((1,2)(3,4),(2,3) ));
3/2
</Example>
</Description> 

</ManSection>
        
</Section>
</Chapter>
</Body>
<Bibliography Databases="Origami"/>

<TheIndex/>

</Book>
